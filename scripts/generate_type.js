#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

const ARGV = process.argv.slice(2);

const {
    DST_DIR_NAME,
    DST_DIR_PATH,
    VULKAN_H,
    PRIMITIVE_TYPE,
    ALL_GENERATED_TYPES
} = require('./constants');

const {
    cToRustVarName,
    capitalizeVarName,
    cToRustEnumValue,
    toRawTypeName,
    toTrueTypeName
} = require('./utils');

main(ARGV);

function main(argv) {
    const typesToGenerate = argv.includes('--all') ? ALL_GENERATED_TYPES : argv;

    typesToGenerate.forEach(generateType);
    refreshModRoot();
}

function generateType(name) {
    if (!generateStruct(name) && !generateEnum(name) && !generateBitFlags(name)) {
        throw new Error(`cannot find type ${name}`);
    }
}

function writeVkType(name, blocks) {
    blocks.unshift('// Generated by `scripts/generate_type.js`');

    const moduleName = cToRustVarName(name);
    const filePath = path.join(DST_DIR_PATH, `${moduleName}.rs`);
    const fileContent = blocks.join('\n\n');

    fs.writeFileSync(filePath, fileContent, 'utf8');
}

function getPrimitiveType(type) {
    return PRIMITIVE_TYPE[type];
}

function generateStruct(name) {
    const match = VULKAN_H.match(new RegExp(`typedef struct ${name} {\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const trueTypeName = toTrueTypeName(name);

    const usedTypes = new Set();
    const rawDefLines = [];
    const trueDefLines = [];
    const fromRawToTrueLines = [];
    const fromTrueToRawLines = [];

    usedTypes.add('std::convert::From');

    match[1].split('\n').forEach(line => {
        let [type, name] = line.split(' ').filter(x => x);
        let rustPrimitiveType = getPrimitiveType(type);
        let isPrimitiveType = !!rustPrimitiveType;
        let rawRustType = isPrimitiveType ? rustPrimitiveType : toRawTypeName(type);
        let trueRustType = isPrimitiveType ? rustPrimitiveType : toTrueTypeName(type);
        let isArray = name.includes('[');
        let isString = false;
        let constantValue = 0;

        if (type === 'VkBool32') {
            trueRustType = 'bool';
        }

        name = name.substring(0, name.length - 1);

        if (isArray) {
            isString = type === 'char';

            const start = name.indexOf('[');
            const end = name.indexOf(']');
            const constantName = name.substring(start + 1, end);

            constantValue = isNaN(+constantName) ? findConstant(constantName) : constantName;
            name = name.substring(0, start);
            rawRustType = `[${rawRustType}; ${constantValue}]`;

            if (isString) {
                trueRustType = 'String';
            } else {
                trueRustType = `[${trueRustType}; ${constantValue}]`;
            }
        }

        let rustName = cToRustVarName(name);

        rawDefLines.push(`${rustName}: ${rawRustType}`);
        trueDefLines.push(`pub ${rustName}: ${trueRustType}`);

        const sourceField = `value.${rustName}`;
        let rawToTrueFieldConversion;
        let trueToRawFieldConversion;

        if (isString) {
            usedTypes.add('std::string::String');
            usedTypes.add('std::ffi::CStr');

            rawToTrueFieldConversion = `unsafe { String::from_utf8_unchecked((&value.device_name).to_vec().into_iter().filter(|x| *x != 0).collect()) }`;
            trueToRawFieldConversion = `[0; ${constantValue}]`; // TODO: actually convert the string into [u8, N]
        } else if (rustPrimitiveType) {
            if (type === 'VkBool32') {
                rawToTrueFieldConversion = `${sourceField} != 0`;
                trueToRawFieldConversion=  `if ${sourceField} { 1 } else { 0 }`;
            } else {
                rawToTrueFieldConversion = sourceField;
                trueToRawFieldConversion = sourceField;
            }
        } else {
            usedTypes.add(`${DST_DIR_NAME}::${cToRustVarName(trueRustType)}::*`);

            rawToTrueFieldConversion = `${trueRustType}::from(&${sourceField})`;
            trueToRawFieldConversion = `${rawRustType}::from(&${sourceField})`;
        }

        fromRawToTrueLines.push(`${rustName}: ${rawToTrueFieldConversion}`);
        fromTrueToRawLines.push(`${rustName}: ${trueToRawFieldConversion}`);
    });

    const useDelaractions = Array.from(usedTypes.values()).map(str => `use ${str};`).join('\n');

    const rawDefinition = [
        `#[repr(C)]`,
        `pub struct ${rawTypeName} {`,
        rawDefLines.map(line => `    ${line}`).join(',\n'),
        `}`
    ].join('\n');

    const hasDefaultTrait = name === 'VkPhysicalDeviceFeatures';

    const trueDefinition = [
        `#[derive(Debug${hasDefaultTrait ? ', Default' : ''})]`,
        `pub struct ${trueTypeName} {`,
        trueDefLines.map(line => `    ${line},`).join('\n'),
        `    pub _index: usize,`,
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a ${rawTypeName}> for ${trueTypeName} {`,
        `    fn from(value: &'a ${rawTypeName}) -> Self {`,
        `        ${trueTypeName} {`,
        fromRawToTrueLines.map(line => `            ${line},`).join('\n'),
        `            _index: 0,`,
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for ${rawTypeName} {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        `        ${rawTypeName} {`,
        fromTrueToRawLines.map(line => `            ${line}`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const noneDefinition = !hasDefaultTrait ? null : [
        `impl ${trueTypeName} {`,
        `    pub fn none() -> Self {`,
        `        ${trueTypeName}::default()`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition, noneDefinition]);

    return true;
}

function generateEnum(name) {
    const match = VULKAN_H.match(new RegExp(`typedef enum ${name}\\s+{\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const rawDefinition = `pub type ${rawTypeName} = i32;`;
    const trueTypeName = toTrueTypeName(name);
    let enumPrefix = name.replace(/[a-z]+/g, str => `${str.toUpperCase()}_`);

    if (name === 'VkResult') {
        enumPrefix = 'VK_';
    }

    const trueDefFields = [];
    const fromLines = [];
    const formatLines = [];

    const fields = match[1].split('\n').map(line => {
        const match = line.match(/^\s*([A-Z_]+)\s*=\s*(-?\d+),?$/);

        if (!match) return null;

        const valueName = match[1];
        const valueInt = match[2];

        if (!valueName.startsWith(enumPrefix)) {
            throw new Error(`enum value ${valueName} does not start with prefix ${enumPrefix}`);
        }

        const rustValue = cToRustEnumValue(valueName.substring(enumPrefix.length));

        return { rustValue, valueInt };
    }).filter(x => x);

    fields.forEach(({rustValue, valueInt}) => {
        trueDefFields.push(`${rustValue} = ${valueInt}`);
        fromLines.push(`${valueInt} => ${trueTypeName}::${rustValue}`);
        formatLines.push(`${trueTypeName}::${rustValue} => write!(f, "${rustValue}")`);
    })

    const useDelaractions = [
        'std::convert::From',
        'std::default::Default'
    ].map(l => `use ${l};`).join('\n');

    const trueDefinition = [
        `#[repr(i32)]`,
        `#[derive(Debug, PartialEq, Copy, Clone)]`,
        `pub enum ${trueTypeName} {`,
        trueDefFields.map(l => `    ${l}`).join(',\n'),
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a i32> for ${trueTypeName} {`,
        `    fn from(value: &'a i32) -> Self {`,
        `        unsafe { *((value as *const i32) as *const ${trueTypeName}) }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for i32 {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        `        *value as i32`,
        `    }`,
        `}`
    ].join('\n');

    const defaultDefinition = [
        `impl Default for ${trueTypeName} {`,
        `    fn default() -> Self {`,
        `        ${trueTypeName}::${fields[0].rustValue}`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition]);

    return true;
}

function generateBitFlags(name) {
    const bitsFlagTypeName = name.substring(0, name.length - 1) + 'Bits';
    const match = VULKAN_H.match(new RegExp(`typedef enum ${bitsFlagTypeName}\\s+{\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const trueTypeName = toTrueTypeName(name);

    const capitalized = capitalizeVarName(name);
    const prefix = capitalized.substring(0, capitalized.indexOf('FLAGS'));
    const suffix = '_BIT';

    const fields = match[1].split('\n').map(line => {
        const match = line.match(/^\s*([A-Z_]+)\s*=\s*(0x[\dA-F]{8}),?\s*$/);

        if (!match) {
            throw new Error(`for enum ${name}: unexpected field "${line}"`);
        }

        return {
            name: match[1],
            value: match[2]
        };
    }).filter(({value}) => value !== '0x7FFFFFFF');

    fields.forEach(field => field.rustName = cToRustVarName(strip(field.name, prefix, suffix)));

    const useDelaractions = [
        'std::convert::From',
    ].map(l => `use ${l};`).join('\n');

    const rawDefinition = `pub type ${rawTypeName} = u32;`;

    const trueDefinition = [
        `#[derive(Debug, Default)]`,
        `pub struct ${trueTypeName} {`,
        fields.map(field => `    pub ${field.rustName}: bool`).join(',\n'),
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a u32> for ${trueTypeName} {`,
        `    fn from(value: &'a u32) -> Self {`,
        `        ${trueTypeName} {`,
        fields.map(field => `            ${field.rustName}: (value & ${field.value}) > 0`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for u32 {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        fields.map(field => `        (if value.${field.rustName} { ${field.value} } else { 0 })`).join(' +\n'),
        `    }`,
        `}`
    ].join('\n');

    const noneDefinition = [
        `impl ${trueTypeName} {`,
        `    pub fn none() -> Self {`,
        `        ${trueTypeName}::default()`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition, noneDefinition]);

    return true;
}

function strip(str, prefix, suffix) {
    return str.substring(prefix.length, str.indexOf(suffix));
}

function findConstant(name) {
    const match = VULKAN_H.match(new RegExp(`#define\\s+${name}\\s+([0-9.]+)`));

    if (!match) {
        throw new Error(`cannot find constant ${name}`);
    }

    return match[1];
}

function refreshModRoot() {
    const filePath = path.join(DST_DIR_PATH, 'mod.rs');
    const moduleNames = fs.readdirSync(DST_DIR_PATH).filter(name => name !== 'mod.rs').map(str => str.replace('.rs', ''));
    const content = [
        ...moduleNames.map(name => `mod ${name};`),
        ``,
        ...moduleNames.map(name => `pub use self::${name}::*;`),
    ].join('\n');

    fs.writeFileSync(filePath, content);
}