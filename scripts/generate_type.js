#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

const ARGV = process.argv.slice(2);

const {
    DST_DIR_NAME,
    DST_DIR_PATH,
    VULKAN_H,
    PRIMITIVE_TYPE
} = require('./constants');

const {
    cToRustVarName,
    capitalizeVarName,
    cToRustEnumValue,
    toRawTypeName,
    toTrueTypeName
} = require('./utils');

const ALL_GENERATED_TYPES = [
    'VkDeviceQueueCreateFlags',
    'VkExtent3D',
    'VkPhysicalDeviceFeatures',
    'VkPhysicalDeviceLimits',
    'VkPhysicalDeviceProperties',
    'VkPhysicalDeviceSparseProperties',
    'VkPhysicalDeviceType',
    'VkQueueFamilyProperties',
    'VkQueueFlags',
    'VkResult',
    'VkStructureType',
    'VkBufferCreateFlags',
    'VkBufferUsageFlags',
    'VkSharingMode',
    'VkMemoryType',
    'VkMemoryPropertyFlags',
    'VkMemoryHeap',
    'VkMemoryHeapFlags',
    'VkPhysicalDeviceMemoryProperties'
];

main(ARGV);

function main(argv) {
    const typesToGenerate = argv.includes('--all') ? ALL_GENERATED_TYPES : argv;

    typesToGenerate.forEach(generateType);
    refreshModRoot();
}

function generateType(name) {
    if (!generateStruct(name) && !generateEnum(name) && !generateBitFlags(name)) {
        throw new Error(`cannot find type ${name}`);
    }
}

function writeVkType(name, blocks) {
    blocks.unshift('// Generated by `scripts/generate_type.js`');

    const moduleName = cToRustVarName(name);
    const filePath = path.join(DST_DIR_PATH, `${moduleName}.rs`);
    const fileContent = blocks.join('\n\n');

    fs.writeFileSync(filePath, fileContent, 'utf8');
}

function getPrimitiveType(type) {
    return PRIMITIVE_TYPE[type];
}

function generateStruct(name) {
    const match = VULKAN_H.match(new RegExp(`typedef struct ${name} {\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const trueTypeName = toTrueTypeName(name);

    const usedTypes = new Set();
    const rawDefLines = [];
    const trueDefLines = [];
    const fromRawToTrueLines = [];
    const fromTrueToRawLines = [];

    usedTypes.add('std::convert::From');

    const fields = match[1].split('\n').map(line => {
        const match = line.match(/\s*([\w* ]+)\s+(\w+)(?:\[(\w+)\])?;\s*$/);

        if (!match) {
            throw new Error(`unexpected line for struct ${name}: "${line}"`);
        }

        return {
            type: match[1].trim(),
            name: match[2],
            arraySize: match[3]
        };
    });

    const paramName = 'value';
    let allowDefaultTraitOnRaw = true;

    fields.forEach((field, index) => {
        let {type, name, arraySize} = field;
        let rustPrimitiveType = getPrimitiveType(type);
        let isPrimitiveType = !!rustPrimitiveType;
        let rawRustType = isPrimitiveType ? rustPrimitiveType : toRawTypeName(type);
        let trueRustType = isPrimitiveType ? rustPrimitiveType : toTrueTypeName(type);
        let originalRawType = rawRustType;
        let originalTrueType = trueRustType;
        let isArray = !!arraySize;
        let isString = false;
        let constantValue = 0;

        if (type === 'VkBool32') {
            trueRustType = 'bool';
        }

        const prevField = fields[index - 1];
        const nextField = fields[index + 1];
        const isVecCount = areCountAndArray(field, nextField);
        const isVec = areCountAndArray(prevField, field);

        if (isArray) {
            isString = type === 'char';
            isArray = !isString;
            constantValue = isNaN(+arraySize) ? findConstant(arraySize) : arraySize;
            rawRustType = `[${rawRustType}; ${constantValue}]`;

            if (isString) {
                allowDefaultTraitOnRaw = false;
                trueRustType = 'String';
            } else if (isVec) {
                trueRustType = `Vec<${trueRustType}>`;
            } else {
                trueRustType = `[${trueRustType}; ${constantValue}]`;
            }
        }

        let rustName = cToRustVarName(name);

        rawDefLines.push(`${rustName}: ${rawRustType}`);

        if (!isVecCount) {
            trueDefLines.push(`pub ${rustName}: ${trueRustType}`);
        }

        const sourceField = `${paramName}.${rustName}`;
        const sourcePrevField = prevField && `${paramName}.${cToRustVarName(prevField.name)}`;
        const sourceNextField = nextField && `${paramName}.${cToRustVarName(nextField.name)}`;
        let rawToTrueFieldConversion = null
        let trueToRawFieldConversion = null;

        if (isString) {
            usedTypes.add('std::string::String');
            usedTypes.add('std::ffi::CStr');
            usedTypes.add('std::os::raw::c_char');

            rawToTrueFieldConversion = `unsafe { String::from_utf8_unchecked(CStr::from_ptr(&${sourceField} as *const c_char).to_bytes().to_vec()) }`;
            trueToRawFieldConversion = `[0; ${constantValue}]`; // TODO: actually convert the string into [u8, N]
        } else if (isVecCount) {
            trueToRawFieldConversion = `${sourceNextField}.len() as u32`;
        } else if (isVec) {
            usedTypes.add('std::vec::Vec');
            usedTypes.add('libc::vec_from_c_ptr');
            usedTypes.add(`${DST_DIR_NAME}::*`);

            rawToTrueFieldConversion = `unsafe { vec_from_c_ptr(${sourcePrevField} as usize, &${sourceField}[0] as *const ${originalRawType}).iter().map(|r| ${originalTrueType}::from(r)).collect() }`;
            trueToRawFieldConversion = `[${isPrimitiveType ? '0' : 'Default::default()'}; ${constantValue}]`; // TODO
        } else if (rustPrimitiveType) {
            if (type === 'VkBool32') {
                rawToTrueFieldConversion = `${sourceField} != 0`;
                trueToRawFieldConversion=  `if ${sourceField} { 1 } else { 0 }`;
            } else {
                rawToTrueFieldConversion = sourceField;
                trueToRawFieldConversion = sourceField;
            }
        } else {
            usedTypes.add(`${DST_DIR_NAME}::*`);

            rawToTrueFieldConversion = `${trueRustType}::from(&${sourceField})`;
            trueToRawFieldConversion = `${rawRustType}::from(&${sourceField})`;
        }

        if (rawToTrueFieldConversion) {
            fromRawToTrueLines.push(`${rustName}: ${rawToTrueFieldConversion}`);
        }

        if (trueToRawFieldConversion) {
            fromTrueToRawLines.push(`${rustName}: ${trueToRawFieldConversion}`);
        }
    });

    const useDelaractions = Array.from(usedTypes.values()).map(str => `use ${str};`).join('\n');

    const rawDefinition = [
        `#[repr(C)]`,
        `#[derive(Clone, Copy${allowDefaultTraitOnRaw ? ', Default' : ''})]`,
        `pub struct ${rawTypeName} {`,
        rawDefLines.map(line => `    ${line}`).join(',\n'),
        `}`
    ].join('\n');

    const hasDefaultTrait = name === 'VkPhysicalDeviceFeatures';

    const trueDefinition = [
        `#[derive(Debug${hasDefaultTrait ? ', Default' : ''})]`,
        `pub struct ${trueTypeName} {`,
        trueDefLines.map(line => `    ${line}`).join(',\n'),
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a ${rawTypeName}> for ${trueTypeName} {`,
        `    fn from(value: &'a ${rawTypeName}) -> Self {`,
        `        ${trueTypeName} {`,
        fromRawToTrueLines.map(line => `            ${line}`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for ${rawTypeName} {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        `        ${rawTypeName} {`,
        fromTrueToRawLines.map(line => `            ${line}`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const noneDefinition = !hasDefaultTrait ? null : [
        `impl ${trueTypeName} {`,
        `    pub fn none() -> Self {`,
        `        ${trueTypeName}::default()`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition, noneDefinition]);

    return true;
}

function generateEnum(name) {
    const match = VULKAN_H.match(new RegExp(`typedef enum ${name}\\s+{\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const rawDefinition = `pub type ${rawTypeName} = i32;`;
    const trueTypeName = toTrueTypeName(name);
    let enumPrefix = name.replace(/[a-z]+/g, str => `${str.toUpperCase()}_`);

    if (name === 'VkResult') {
        enumPrefix = 'VK_';
    }

    const trueDefFields = [];
    const fromLines = [];
    const formatLines = [];

    const fields = match[1].split('\n').map(line => {
        const match = line.match(/^\s*([A-Z_]+)\s*=\s*(-?\d+),?$/);

        if (!match) return null;

        const valueName = match[1];
        const valueInt = match[2];

        if (!valueName.startsWith(enumPrefix)) {
            throw new Error(`enum value ${valueName} does not start with prefix ${enumPrefix}`);
        }

        const rustValue = cToRustEnumValue(valueName.substring(enumPrefix.length));

        return { rustValue, valueInt };
    }).filter(x => x);

    fields.forEach(({rustValue, valueInt}) => {
        trueDefFields.push(`${rustValue} = ${valueInt}`);
        fromLines.push(`${valueInt} => ${trueTypeName}::${rustValue}`);
        formatLines.push(`${trueTypeName}::${rustValue} => write!(f, "${rustValue}")`);
    })

    const useDelaractions = [
        'std::convert::From',
        'std::default::Default'
    ].map(l => `use ${l};`).join('\n');

    const trueDefinition = [
        `#[repr(i32)]`,
        `#[derive(Debug, PartialEq, Copy, Clone)]`,
        `pub enum ${trueTypeName} {`,
        trueDefFields.map(l => `    ${l}`).join(',\n'),
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a i32> for ${trueTypeName} {`,
        `    fn from(value: &'a i32) -> Self {`,
        `        unsafe { *((value as *const i32) as *const ${trueTypeName}) }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for i32 {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        `        *value as i32`,
        `    }`,
        `}`
    ].join('\n');

    const defaultDefinition = [
        `impl Default for ${trueTypeName} {`,
        `    fn default() -> Self {`,
        `        ${trueTypeName}::${fields[0].rustValue}`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition]);

    return true;
}

function generateBitFlags(name) {
    const bitsFlagTypeName = name.substring(0, name.length - 1) + 'Bits';
    const match = VULKAN_H.match(new RegExp(`typedef enum ${bitsFlagTypeName}\\s+{\n([^}]+)\n}`, 'm'));

    if (!match) return false;

    const rawTypeName = toRawTypeName(name);
    const trueTypeName = toTrueTypeName(name);

    const capitalized = capitalizeVarName(name);
    const prefix = capitalized.substring(0, capitalized.indexOf('FLAGS'));
    const suffix = '_BIT';

    const fields = match[1].split('\n').map(line => {
        const match = line.match(/^\s*([A-Z_]+)\s*=\s*(0x[\dA-F]{8})|([A-Z_]+),?\s*$/);

        if (!match) {
            throw new Error(`for enum ${name}: unexpected field "${line}"`);
        }

        return {
            name: match[1],
            value: match[2] || match[3]
        };
    }).filter(({value}) => value !== '0x7FFFFFFF' && value.startsWith('0x'));

    fields.forEach(field => field.rustName = cToRustVarName(strip(field.name, prefix, suffix)));

    const useDelaractions = [
        'std::convert::From',
    ].map(l => `use ${l};`).join('\n');

    const rawDefinition = `pub type ${rawTypeName} = u32;`;

    const trueDefinition = [
        `#[derive(Debug, Default)]`,
        `pub struct ${trueTypeName} {`,
        fields.map(field => `    pub ${field.rustName}: bool`).join(',\n'),
        `}`
    ].join('\n');

    const fromRawToTrueDefinition = [
        `impl<'a> From<&'a u32> for ${trueTypeName} {`,
        `    fn from(value: &'a u32) -> Self {`,
        `        ${trueTypeName} {`,
        fields.map(field => `            ${field.rustName}: (value & ${field.value}) > 0`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    const fromTrueToRawDefinition = [
        `impl<'a> From<&'a ${trueTypeName}> for u32 {`,
        `    fn from(value: &'a ${trueTypeName}) -> Self {`,
        fields.map(field => `        (if value.${field.rustName} { ${field.value} } else { 0 })`).join(' +\n'),
        `    }`,
        `}`
    ].join('\n');

    const noneAndAllDefinition = [
        `impl ${trueTypeName} {`,
        `    pub fn none() -> Self {`,
        `        ${trueTypeName}::default()`,
        `    }`,
        ``,
        `    pub fn all() -> Self {`,
        `        ${trueTypeName} {`,
        fields.map(field => `            ${field.rustName}: true`).join(',\n'),
        `        }`,
        `    }`,
        `}`
    ].join('\n');

    writeVkType(name, [useDelaractions, rawDefinition, trueDefinition, fromRawToTrueDefinition, fromTrueToRawDefinition, noneAndAllDefinition]);

    return true;
}

function areCountAndArray(field1, field2) {
    return field1 && field2 && field1.name.endsWith('Count') && field1.name.substring(0, field1.name.length - 'Count'.length) + 's' === field2.name;
}

function strip(str, prefix, suffix) {
    return str.substring(prefix.length, str.indexOf(suffix));
}

function findConstant(name) {
    const match = VULKAN_H.match(new RegExp(`#define\\s+${name}\\s+([0-9.]+)`));

    if (!match) {
        throw new Error(`cannot find constant ${name}`);
    }

    return match[1];
}

function refreshModRoot() {
    const filePath = path.join(DST_DIR_PATH, 'mod.rs');
    const moduleNames = fs.readdirSync(DST_DIR_PATH).filter(name => name !== 'mod.rs').map(str => str.replace('.rs', ''));
    const content = [
        ...moduleNames.map(name => `mod ${name};`),
        ``,
        ...moduleNames.map(name => `pub use self::${name}::*;`),
    ].join('\n');

    fs.writeFileSync(filePath, content);
}