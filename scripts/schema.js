#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

const { parseType, parseFunction, isHandle } = require('./parse');
const { DST_DIR_PATH } = require('./constants');

const PRIMITIVE_TYPES = {
    uint32_t: 'u32',
    uint16_t: 'u16',
    uint8_t: 'u8',
    int32_t: 'i32',
    int16_t: 'i16',
    int8_t: 'i8',
    char: 'c_char',
    float: 'f32',
    double: 'f64',
    size_t: 'usize',
    void: 'c_void',
    VkAllocationCallbacks: 'c_void'
};

const META_TYPE_TO_BUILD_FUNC = {
    handle: buildHandle,
    struct: buildStruct,
    enum: buildEnum,
    flags: buildBitFlags
};

const SCHEMA = {
    VkInstance: {
        new: 'vkCreateInstance',
        drop: 'vkDestroyInstance'
    },
    VkBuffer: {
        // new: 'vkCreateBuffer',
        // drop: 'vkDestroyBuffer'
    },
    VkPhysicalDevice: {
        // getList: 'vkEnumeratePhysicalDevices',
        // getSurfaceCapabilities: 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR',
        // doesSupportSurface: 'vkGetPhysicalDeviceSurfaceSupportKHR',
        // getSurfacePresentModes: 'vkGetPhysicalDeviceSurfacePresentModesKHR',
        // createLogicalDevice: 'VkDevice::new'
    },
    VkDevice: {
        // new: 'vkCreateDevice'
    }
};

const DEFINITIONS = {};

main();

function main() {
    // buildType('VkResult');
    // buildType('VkInstance');
    buildType('VkBufferCreateFlags');

    Object.entries(DEFINITIONS).forEach(([typeName, typeDefinition]) => {
        const fileContent = generateTypeFileContent(typeName, typeDefinition);
        writeVkType(typeName, fileContent);
    });

    refreshModRs(DST_DIR_PATH);
}

function refreshModRs(dirPath) {
    const filePath = path.join(dirPath, 'mod.rs');
    const moduleNames = fs.readdirSync(dirPath).filter(name => name !== 'mod.rs').map(str => str.replace('.rs', ''));
    const content = [
        ...moduleNames.map(name => `mod ${name};`),
        ``,
        ...moduleNames.map(name => `pub use self::${name}::*;`),
    ].join('\n');

    fs.writeFileSync(filePath, content);
}

function writeVkType(name, blocks) {
    blocks.unshift('// Generated by `scripts/schema.js`');

    const moduleName = toSnakeCase(name);
    const filePath = path.join(DST_DIR_PATH, `${moduleName}.rs`);
    const fileContent = blocks.map(block => {
        if (Array.isArray(block)) {
            return blockToStr(block);
        } else {
            return block;
        }
    }).filter(x => !!x).join('\n\n');

    console.log(fileContent);

    fs.writeFileSync(filePath, fileContent, 'utf8');
}

function methodToBlock(method) {
    const { name, args, returnType, body, public } = method;

    return [
        `${public ? 'pub ' : ''}fn ${name}(${args.map(({name, type}) => (name ? `${name}: `: '') + type).join(', ')})` + (returnType ? ` -> ${returnType}` : ''),
            body
    ];
}

function externalArgumentToRust(arg) {
    const { name, fullType, typeName, isPointer, isConst } = arg;

    const type = `${isPointer ? `*${isConst ? 'const ' : 'mut '}` : ''}${toRawTypeName(typeName)}`;

    return `${toSnakeCase(name)}: ${type}`;
}

function externalMethodToBlock(method) {
    const { name, returnType, args } = method;

    return `fn ${name}(${args.map(externalArgumentToRust).join(', ')})${returnType !== 'void' ? `-> RawVkResult`: ''};`;
}

function typeToBlock(typeName, definition) {
    const metaType = definition.type;

    if (metaType === 'typedef') {
        return `pub type ${typeName} = ${definition.target};`;
    } else if (metaType === 'struct') {
        const header = definition.reprC ? '#[repr(C)]\n' : '';

        return [`${header}pub struct ${typeName}`, definition.fields.map(({name, type, public}) => `${public ? 'pub ' : ''}${name}: ${type},`)];
    } else if (metaType === 'enum') {
        const header = ['#[repr(i32)]', '#[derive(Debug, PartialEq, Copy, Clone)]'].join('\n');
        
        return [`${header}\npub enum ${typeName}`, definition.fields.map(({name, value}) => `${name} = ${value},`)];
    }
}

function generateTypeFileContent(typeName, definition) {
    const { rawTypeName, wrappedTypeName, uses, rawDefinition, wrappedDefinition, methods, rawDropMethod, wrappedDropMethod, externFunctions, fromRawToWrapped, fromWrappedToRaw } = definition;

    const baseUses = [];

    if (fromRawToWrapped || fromWrappedToRaw) {
        baseUses.push('vk::VkFrom');
    }

    if (rawDropMethod || wrappedDropMethod) {
        baseUses.push(`std::ops::Drop`);
    }

    const blocks = [
        baseUses.concat(uses || []).map(use => `use ${use};`).join('\n'),
        typeToBlock(rawTypeName, rawDefinition),
        typeToBlock(wrappedTypeName, wrappedDefinition),
        methods ? [`impl ${wrappedTypeName}`].concat(methods.map(methodToBlock)) : '',
        fromRawToWrapped ? [`impl VkFrom<${rawTypeName}> for ${wrappedTypeName}`, methodToBlock(fromRawToWrapped)] : '',
        fromWrappedToRaw ? [`impl VkFrom<${wrappedTypeName}> for ${rawTypeName}`, methodToBlock(fromWrappedToRaw)] : '',
        rawDropMethod ? [`impl Drop for ${rawTypeName}`, methodToBlock(rawDropMethod)] : '',
        wrappedDropMethod ? [`impl Drop for ${wrappedTypeName}`, methodToBlock(wrappedDropMethod)] : '',
        externFunctions ? [`extern`, externFunctions.map(externalMethodToBlock)] : ''
    ];

    return blocks;
}

function buildType(typeName) {
    if (typeName in PRIMITIVE_TYPES || typeName in DEFINITIONS) {
        return;
    }

    DEFINITIONS[typeName] = null;

    const cDef = parseType(typeName);
    const metaType = cDef.type;
    const rawInfo = metaType === 'handle' ? (SCHEMA[typeName] || {}) : cDef;
    const definition = META_TYPE_TO_BUILD_FUNC[metaType](typeName, rawInfo);

    definition.metaType = metaType;
    DEFINITIONS[typeName] = definition;
}

function buildStruct(typeName, parsed) {
    const rawTypeName = toRawTypeName(typeName);
    const wrappedTypeName = toWrappedTypeName(typeName);

    const uses = [
        `std::ops::Drop`,
        `std::vec::Vec`,
        `std::ptr::null`,
        `vk::VkFrom`,
        `vk::RawVkHandle`,
        'libc::*'
    ];

    let lifetimeIdCounter = 0;
    const srcVar = 'value';
    const lifetimeIds = [];
    const rawFields = [];
    const wrappedFields = [];
    const fromRawToWrappedFields = [];
    const fromWrappedToRawFields = [];
    const dropStatements = [];

    parsed.fields.forEach((field, index) => {
        const prevField = parsed.fields[index - 1];
        const nextField = parsed.fields[index + 1];

        const rustFieldName = getRustFieldName(field);
        const rawRustFieldType = getRawRustFieldType(field);
        const isCount = areCountAndArray(field, nextField);
        const isArrayPtr = areCountAndArray(prevField, field);
        const isStaticArray = !!field.arraySize;
        const isPointer = field.isPointer;
        const isTypeChar = field.typeName === 'char';
        const isPrimitiveType = !!PRIMITIVE_TYPES[field.typeName];
        const isHandleType = isHandle(field.typeName);
        const representIndex = doesFieldRepresentIndex(field);

        rawFields.push({ name: rustFieldName, type: rawRustFieldType });

        if (field.name === 'sType') {
            fromWrappedToRawFields.push(`${rustFieldName}: VkFrom::from(&VkStructure::${typeName.substring(2)})`);
        } else if (field.name === 'pNext') {
            fromWrappedToRawFields.push(`${rustFieldName}: null()`);
        } else if (isCount) {
            const vecFieldName = getRustFieldName(nextField);
            fromWrappedToRawFields.push(`${rustFieldName}: ${srcVar}.${vecFieldName}.len() as u32`);
        } else {
            const src = `${srcVar}.${rustFieldName}`;
            const ref = isHandleType ? '' : '&';
            const wrappedToRawCollectionConversion = isPrimitiveType
                ? (representIndex ? `.iter().map(|x| x as u32).collect()` : '')
                : `.iter().map(|x| VkFrom::from(x)).collect()`;
            const wrappedToRawSingleEltConversion = isPrimitiveType
                ? (representIndex ? `${src} as u32` : src)
                : `VkFrom::from(${ref}${src})`;
            const rawToWrappedCollectionConversion = isPrimitiveType
                ? (representIndex ? `.iter().map(|x| x as usize).collect()` : '')
                : `.iter().map(|x| VkFrom::from(x)).collect()`;
            const rawToWrappedSingleEltConversion = isPrimitiveType
                ? (representIndex ? `${src} as usize` : src)
                : `VkFrom::from(&${src})`;
            const wrappedTypeName = representIndex ? 'usize' : toWrappedTypeName(field.typeName);
            let wrappedFieldType = null;

            if (isArrayPtr) {
                const countVar = `${srcVar}.${getRustFieldName(prevField)}`;

                if (isStringArray(field)) {
                    wrappedFieldType = `Vec<String>`;
                    fromWrappedToRawFields.push(`${rustFieldName}: copy_as_c_string_array(&${src})`);
                    fromRawToWrappedFields.push(`${rustFieldName}: copy_as_string_array(${countVar}, ${src})`);
                } else {
                    wrappedFieldType = `Vec<${wrappedTypeName}>`;
                    fromWrappedToRawFields.push(`${rustFieldName}: copy_as_c_array(&${src}${wrappedToRawCollectionConversion})`);
                    fromRawToWrappedFields.push(`${rustFieldName}: vec_from_c_ptr(${countVar}, ${src})${rawToWrappedCollectionConversion}`);
                }
            } else if (isPointer) {
                if (isTypeChar) {
                    wrappedFieldType = 'String';
                    fromWrappedToRawFields.push(`${rustFieldName}: copy_as_c_string(&${src})`);
                    fromRawToWrappedFields.push(`${rustFieldName}: copy_as_string(${src})`)
                } else {
                    if (isHandleType) {
                        const lifetimeId = String.fromCharCode('a'.charCodeAt(0) + lifetimeIdCounter++);
                        lifetimeIds.push(lifetimeId);
                        wrappedFieldType = `&'${lifetimeId} ${wrappedTypeName}`
                    } else {
                        wrappedFieldType = wrappedTypeName;
                    }
                    fromWrappedToRawFields.push(`${rustFieldName}: copy_as_c_ptr(&${wrappedToRawSingleEltConversion})`);
                    fromRawToWrappedFields.push(`${rustFieldName}: *${rawToWrappedSingleEltConversion}`);
                }
            } else if (isStaticArray) {
                if (isTypeChar) {
                    wrappedFieldType = 'String';
                    fromWrappedToRawFields.push(`${rustFieldName}: [0; ${arraySize}]`);
                    fromRawToWrappedFields.push(`${rustFieldName}: copy_as_string(&${src} as *const c_char)`);
                } else {
                    wrappedFieldType = `[${wrappedTypeName}, ${arraySize}]`;
                    fromWrappedToRawFields.push(`${rustFieldName}: ${src}${wrappedToRawCollectionConversion}`);
                    fromRawToWrappedFields.push(`${rustFieldName}: ${src}${rawToWrappedCollectionConversion}`);
                }
            } else {
                if (isHandleType) {
                    const lifetimeId = String.fromCharCode('a'.charCodeAt(0) + lifetimeIdCounter++);
                    lifetimeIds.push(lifetimeId);
                    wrappedFieldType = `&'${lifetimeId} ${wrappedTypeName}`
                } else {
                    wrappedFieldType = wrappedTypeName;
                }
                fromWrappedToRawFields.push(`${rustFieldName}: ${wrappedToRawSingleEltConversion}`);
                fromRawToWrappedFields.push(`${rustFieldName}: ${rawToWrappedSingleEltConversion}`);
            }

            wrappedFields.push({ name: rustFieldName, type: wrappedFieldType });
        }
    });

    const fromWrappedToRaw = [rawTypeName, fromWrappedToRawFields.map(x => `${x},`)];
    const fromRawToWrapped = [wrappedTypeName, fromRawToWrappedFields.map(x => `${x},`)];

    return {};
}

function doesFieldRepresentIndex(field) {
    return field.typeName === 'uint32_t' && /Index|Indices/.test(field.name);
}

function isStringArray(field) {
    return field.fullType === 'const char* const*';
}

function getRawRustFieldType(field) {
    const { name, typeName, isPointer, arraySize } = field;

    if (name === 'pNext') {
        return `*const c_void`;
    } else if (isStringArray(field)) {
        return `*mut *mut c_char`;
    } else {
        const rawTypeName = toRawTypeName(typeName);

        if (isPointer) {
            return `*mut ${rawTypeName}`;
        } else if (arraySize) {
            return `[${rawTypeName}, ${arraySize}]`;
        } else {
            return rawTypeName;
        }
    }
}

function getRustFieldName({name}) {
    return toSnakeCase(name.replace(/^(p{1,2}|s)[A-Z]/, str => str[str.length - 1]));
}

function areCountAndArray(field1, field2) {
    return field1 && field2 && field1.name.endsWith('Count') && field1.fullType === 'uint32_t' && field2.isPointer && field2.typeName !== 'char';
}

function findEnumPrefix(typeName) {
    if (typeName === 'VkResult') {
        return 'VK_';
    }

    return typeName.replace(/[A-Z]+/g, `_$&`).toUpperCase().substring(1);
}

function buildEnum(typeName, rawInfo) {
    const rawTypeName = toRawTypeName(typeName);
    const wrappedTypeName = toWrappedTypeName(typeName);
    const rawDefinition = { type: 'typedef', target: 'i32' };

    const prefix = findEnumPrefix(typeName);

    const wrappedDefinition = {
        type: 'enum',
        fields: rawInfo.fields.map(({name, value}) => {
            return {
                name: toPascalCase(name.substring(prefix.length)),
                value: value
            };
        })
    };

    const fromWrappedToRaw = {
        name: 'from',
        args: [{name: 'value', type: `&${wrappedTypeName}`}],
        returnType: 'Self',
        body: [`*value as i32`]
    };

    const fromRawToWrapped = {
        name: 'from',
        args: [{name: 'value', type: `&${rawTypeName}`}],
        returnType: 'Self',
        body: [`unsafe`, [`*((value as *const i32) as *const ${wrappedTypeName})`]]
    };

    return { rawTypeName, wrappedTypeName, rawDefinition, wrappedDefinition, fromWrappedToRaw, fromRawToWrapped };
}

function buildBitFlags(typeName, rawInfo) {
    const rawTypeName = toRawTypeName(typeName);
    const wrappedTypeName = toWrappedTypeName(typeName);
    const rawDefinition = { type: 'typedef', target: 'u32' };

    const prefix = typeName
        .substring(0, typeName.indexOf('Flags'))
        .replace(/[a-z]+/g, `$&_`).toUpperCase();

    const fields = rawInfo.fields.map(({name, value}) => {
        return {
            name: name.substring(prefix.length).replace('_BIT', '').toLowerCase(),
            value: value
        };
    });

    const wrappedDefinition = {
        type: 'struct',
        fields: fields.map(({name}) => ({ name: name, type: 'bool', public: true }))
    };

    return { rawTypeName, wrappedTypeName, rawDefinition, wrappedDefinition };
}

function buildHandle(typeName, rawInfo) {
    const uses = [
        `std::vec::Vec`,
        `std::ptr::null`,
        `vk::RawVkHandle`,
        `libc::c_void`
    ];

    const rawTypeName = toRawTypeName(typeName);
    const wrappedTypeName = toWrappedTypeName(typeName);
    const fields = [];
    const rawDefinition = { type: 'typedef', target: 'RawVkHandle' };
    const wrappedDefinition = { type: 'struct', fields: fields };
    const methods = [];
    const externFunctions = [];
    let wrappedDropMethod = null;
    let rawDropMethod = null;
    let fromWrappedToRaw = null;
    let fromRawToWrapped = null;

    fields.push({name: '_handle', type: rawTypeName});
    
    methods.push({
        name: 'handle',
        args: [{type: '&self'}],
        returnType: rawTypeName,
        body: ['self._handle'],
        public: true
    });

    if (rawInfo.drop) {
        const cMethodName = rawInfo.drop;
        const cMethod = parseFunction(cMethodName);
        const cArgs = cMethod.args.map(arg => {
            if (arg.name === 'pAllocator') {
                return 'null()';
            } else {
                buildType(arg.typeName);

                const rawArgType = toRawTypeName(arg.typeName);
                let field = fields.find(({type}) => type === rawArgType);

                if (!field) {
                    field = {name: `_${arg.name}`, type: rawArgType};
                    fields.push(field);
                }

                return `self.${field.name}`;
            }
        });
        const body = ['unsafe', [`${cMethodName}(${cArgs.join(', ')});`]];
        
        wrappedDropMethod = {
            name: 'drop',
            args: [{type: '&mut self'}],
            returnType: null,
            body: body
        };

        externFunctions.push(cMethod);
    }

    Object.entries(rawInfo).forEach(([methodName, def]) => {
        if (methodName === 'drop') {
            return;
        }

        let statements = [];
        let returnType = null;
        let methodArguments = [];
        let static = false;
        let unsafe = false;
        let setAdditionalFields = [];

        if (!def.includes('::')) {
            const cMethod = parseFunction(def);
            const cMethodArgs = cMethod.args;
            const lastArg = cMethodArgs[cMethodArgs.length - 1];
            const instanceVarName = toSnakeCase(lastArg.typeName.substring(2));
            const beforeLastArg = cMethodArgs[cMethodArgs.length - 2];
            const createSomething = lastArg.isPointer && !lastArg.isConst;
            const createList = createSomething && beforeLastArg.isPointer && !beforeLastArg.isConst && beforeLastArg.typeName === 'uint32_t';
            const isConstructor = createSomething && lastArg.typeName === typeName;
            const returnVkResult = cMethod.returnType === 'VkResult';
            const argsForCMethod = cMethodArgs.map((arg, index) => {
                buildType(arg.typeName);

                if (createSomething && index === cMethodArgs.length - 1) {
                    return 'ptr';
                } else if (createList && index === cMethodArgs.length - 2) {
                    return 'count';
                } else if (arg.name === 'pAllocator') {
                    return 'null()';
                } else {
                    const rawArgType = toRawTypeName(arg.typeName);
                    const wrappedArgType = toWrappedTypeName(arg.typeName);
    
                    if (arg.isPointer && arg.isConst) {
                        // Structure that needs to be passed to the rust method
    
                        const rustArgName = toSnakeCase(arg.name.substring(1));
                        const rawVarName = `raw_${rustArgName}`;
                        const ptrVarName = `${rawVarName}_ptr`;
    
                        statements.push(
                            `let mut ${rawVarName} = ${rawArgType}::from(${rustArgName});`, // TODO: properly convert VkBool32
                            `let ${ptrVarName} = &mut ${rawVarName} as *mut ${rawArgType};`
                        );
    
                        methodArguments.push({
                            name: rustArgName,
                            type: `&${wrappedArgType}`
                        });
    
                        return ptrVarName;
                    } else if (!arg.isPointer) {
                        if (arg.typeName.startsWith('Vk')) {
                            const field = fields.find(({type}) => type === rawArgType);
    
                            if (field && !isConstructor) {
                                return `self.${field.name}`;
                            } else {
                                const rustArgName = toSnakeCase(arg.name);
                                const handleName = `${rustArgName}_handle`;
    
                                statements.push(`let ${handleName} = ${rustArgName}.handle();`);
                                methodArguments.push({ name: rustArgName, type: `&${wrappedArgType}` });
    
                                if (isConstructor && field) {
                                    setAdditionalFields.push(`${instanceVarName}.${field.name} = ${handleName};`);
                                }
    
    
                                return handleName;
                            }
                        } else {
                            const rustArgName = toSnakeCase(arg.name);
                            const convertToUsize = rustArgName.endsWith('_index') && wrappedArgType === 'u32';
                            const rustArgType = convertToUsize ? 'usize' : wrappedArgType;
                            methodArguments.push({ name: rustArgName, type: rustArgType });
    
                            return rustArgName + (convertToUsize ? ' as u32' : '');
                        }
                    }
                }
    
                return '<missing>';
            });
    
            externFunctions.push(cMethod);

            unsafe = true;

            if (isConstructor) {
                static = true;
            }
    
            if (createSomething) {
                returnType = toWrappedTypeName(lastArg.typeName);
    
                if (createList) {
                    returnType = `Vec<${returnType}>`;
                }
    
                if (returnVkResult) {
                    returnType = `Result<${returnType}, VkResult>`;
                }
    
                const vkWrapperCallName = `vk_call_retrieve_${createList ? 'list' : 'single'}${returnVkResult ? '' : '_unchecked'}`;
                const lambdaArgs = createList ? '|count, ptr|' : '|ptr|';
                const callback = `|${instanceVarName}| { ${setAdditionalFields.join(' ')} }`;
                statements.push(`${vkWrapperCallName}(\n    ${lambdaArgs} ${cMethod.name}(${argsForCMethod.join(', ')}),\n    ${callback}\n)`);
            } else {
                throw new Error(`method ${cMethod.name} does not seem to retrieve anything`);
            }
        } else {
            const [targetTypeName, targetMethodName] = def.split('::');

            buildType(targetTypeName);

            const rustTargetMethodName = toSnakeCase(targetMethodName);
            const targetMethod = DEFINITIONS[targetTypeName].methods.find(m => m.name === rustTargetMethodName);
            const targetCallArgs = [];

            targetMethod.args.forEach(({type, name}) => {
                if (type === `&${wrappedTypeName}`) {
                    targetCallArgs.push('self');
                } else {
                    targetCallArgs.push(name);
                    methodArguments.push({name, type});
                }
            });

            returnType = targetMethod.returnType
            statements.push(`${targetTypeName}::${rustTargetMethodName}(${targetCallArgs.join(', ')})`);
        }

        if (!static) {
            methodArguments.unshift({type: '&self'});
        }
        
        const method = {
            name: toSnakeCase(methodName),
            args: methodArguments,
            returnType: returnType,
            body: unsafe ? ['unsafe', statements] : statements,
            public: true
        };

        methods.push(method);
    });

    fromWrappedToRaw = {
        name: 'from',
        args: [{name: 'value', type: `&${wrappedTypeName}`}],
        returnType: 'Self',
        body: [`value._handle`]
    };

    fromRawToWrapped = {
        name: 'from',
        args: [{name: 'value', type: `&${rawTypeName}`}],
        returnType: 'Self',
        body: ['Self', fields.map(({name}) => `${name}: ${name === '_handle' ? '*value' : 'VK_NULL_HANDLE'},`)]
    }

    // methods.forEach(method => console.log(methodToStr(method)));

    return { rawTypeName, wrappedTypeName, uses, rawDefinition, wrappedDefinition, methods, rawDropMethod, wrappedDropMethod, externFunctions, fromRawToWrapped, fromWrappedToRaw };
}

function toRawTypeName(typeName) {
    return PRIMITIVE_TYPES[typeName] || `Raw${typeName}`;
}

function toWrappedTypeName(typeName) {
    if (typeName === 'VkBool32') {
        return 'bool';
    }

    return PRIMITIVE_TYPES[typeName] || typeName.replace('FlagBits', 'Flags');
}

function blockToStr(block, indent) {
    const spaces = indentToSpaces(indent);
    let result;

    if (typeof block === 'string') {
        result = `\n${block.split('\n').map(line => `${spaces}${line}`).join('\n')}`;
    } else {
        result = ` {${block.map(b => blockToStr(b, inc(indent))).join('')}\n${spaces}}`
    }

    if (indent === undefined) {
        result = result.substring(2, result.length - 2).trim();
    }

    return result;
}

function inc(value) {
    return value === undefined ? 0 : value + 1;
}

function indentToSpaces(indent) {
    if (!indent) return '';

    return new Array(indent).fill('    ').join('');
}

function toSnakeCase(str) {
    return str
        .replace(/[A-Z0-9]+/g, str => str.charAt(0) + str.substring(1).toLowerCase())
        .split(/(?=[A-Z])/).join('_').toLowerCase();
}

function toPascalCase(str) {
    return str.split('_').map(word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()).join('');
}