// Generated by `scripts/generate_vk.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ptr;
use std::mem;
use vk::*;

pub struct Vk;

impl Vk {
    
    pub fn create_instance(create_info: &VkInstanceCreateInfo) -> Result<VkInstance, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_instance = &mut mem::uninitialized() as *mut RawVkInstance;
            
            let vk_result = vkCreateInstance(raw_create_info, ptr::null(), raw_instance);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut instance = new_vk_value(raw_instance);
            let fn_table = Box::into_raw(Box::new(VkInstanceFunctionTable::new(*raw_instance)));
            let parent_instance = *raw_instance;
            let parent_device = 0;
            VkSetup::vk_setup(&mut instance, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(instance)
        }
    }
    
    pub fn enumerate_instance_extension_properties(layer_name: Option<&str>) -> Result<Vec<VkExtensionProperties>, VkResult> {
        unsafe {
            let raw_layer_name = new_ptr_string_checked(layer_name);
            let mut raw_properties : *mut RawVkExtensionProperties = ptr::null_mut();
            let raw_property_count = &mut mem::uninitialized() as *mut u32;
            let vk_result = vkEnumerateInstanceExtensionProperties(raw_layer_name, raw_property_count, raw_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            raw_properties = malloc((*raw_property_count as usize) * mem::size_of::<RawVkExtensionProperties>()) as *mut RawVkExtensionProperties;
            
            let vk_result = vkEnumerateInstanceExtensionProperties(raw_layer_name, raw_property_count, raw_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let properties = new_vk_array(*raw_property_count, raw_properties);
            free_ptr(raw_layer_name);
            free_vk_ptr_array(*raw_property_count as usize, raw_properties);
            Ok(properties)
        }
    }
    
    pub fn enumerate_instance_layer_properties() -> Result<Vec<VkLayerProperties>, VkResult> {
        unsafe {
            let mut raw_properties : *mut RawVkLayerProperties = ptr::null_mut();
            let raw_property_count = &mut mem::uninitialized() as *mut u32;
            let vk_result = vkEnumerateInstanceLayerProperties(raw_property_count, raw_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            raw_properties = malloc((*raw_property_count as usize) * mem::size_of::<RawVkLayerProperties>()) as *mut RawVkLayerProperties;
            
            let vk_result = vkEnumerateInstanceLayerProperties(raw_property_count, raw_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let properties = new_vk_array(*raw_property_count, raw_properties);
            free_vk_ptr_array(*raw_property_count as usize, raw_properties);
            Ok(properties)
        }
    }
    
    pub fn enumerate_instance_version() -> Result<VkVersion, VkResult> {
        unsafe {
            let raw_api_version = &mut mem::uninitialized() as *mut u32;
            
            let vk_result = vkEnumerateInstanceVersion(raw_api_version);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let api_version = new_vk_value(raw_api_version);
            Ok(api_version)
        }
    }
}

extern {
    fn vkCreateInstance(create_info: *mut RawVkInstanceCreateInfo, allocator: *const c_void, instance: *mut RawVkInstance) -> RawVkResult;
    fn vkEnumerateInstanceExtensionProperties(layer_name: *mut c_char, property_count: *mut u32, properties: *mut RawVkExtensionProperties) -> RawVkResult;
    fn vkEnumerateInstanceLayerProperties(property_count: *mut u32, properties: *mut RawVkLayerProperties) -> RawVkResult;
    fn vkEnumerateInstanceVersion(api_version: *mut u32) -> RawVkResult;
}