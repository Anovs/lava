// Generated by `scripts/generate_vk.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ptr;
use std::mem;
use std::cmp;
use vk::*;

pub type RawVkDevice = u64;

#[derive(Debug, Copy, Clone)]
pub struct VkDevice {
    _handle: RawVkDevice,
    _parent_instance: RawVkInstance,
    _parent_device: RawVkDevice,
    _fn_table: *mut VkInstanceFunctionTable
}

impl VkRawType<VkDevice> for RawVkDevice {
    fn vk_to_wrapped(src: &RawVkDevice) -> VkDevice {
        VkDevice {
            _handle: *src,
            _parent_instance: 0,
            _parent_device: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkWrappedType<RawVkDevice> for VkDevice {
    fn vk_to_raw(src: &VkDevice, dst: &mut RawVkDevice) {
        *dst = src._handle
    }
}

impl Default for VkDevice {
    fn default() -> VkDevice {
        VkDevice {
            _handle: 0,
            _parent_instance: 0,
            _parent_device: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkSetup for VkDevice {
    fn vk_setup(&mut self, fn_table: *mut VkInstanceFunctionTable, instance: RawVkInstance, device: RawVkDevice) {
        self._parent_instance = instance;
        self._parent_device = device;
        self._fn_table = fn_table;
    }
}

impl VkDevice {
    
    pub fn handle(&self) -> u64 {
        self._handle
    }
    
    pub fn destroy(&self) {
        unsafe {
            ((&*self._fn_table).vkDestroyDevice)(self._handle, ptr::null());
        }
    }
    
    pub fn get_queue(&self, queue_family_index: usize, queue_index: usize) -> VkQueue {
        unsafe {
            let raw_queue_family_index = vk_to_raw_value(&queue_family_index);
            let raw_queue_index = vk_to_raw_value(&queue_index);
            let raw_queue = &mut mem::uninitialized() as *mut RawVkQueue;
            
            ((&*self._fn_table).vkGetDeviceQueue)(self._handle, raw_queue_family_index, raw_queue_index, raw_queue);
            
            let mut queue = new_vk_value(raw_queue);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut queue, fn_table, parent_instance, parent_device);
            queue
        }
    }
    
    pub fn wait_idle(&self) -> VkResult {
        unsafe {
            let vk_result = ((&*self._fn_table).vkDeviceWaitIdle)(self._handle);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn allocate_memory(&self, allocate_info: &VkMemoryAllocateInfo) -> Result<VkDeviceMemory, VkResult> {
        unsafe {
            let raw_allocate_info = new_ptr_vk_value(allocate_info);
            let raw_memory = &mut mem::uninitialized() as *mut RawVkDeviceMemory;
            
            let vk_result = ((&*self._fn_table).vkAllocateMemory)(self._handle, raw_allocate_info, ptr::null(), raw_memory);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut memory = new_vk_value(raw_memory);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut memory, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_allocate_info);
            Ok(memory)
        }
    }
    
    pub fn free_memory(&self, memory: Option<&VkDeviceMemory>) {
        unsafe {
            let raw_memory = if memory.is_some() { vk_to_raw_value(memory.unwrap()) } else { 0 };
            ((&*self._fn_table).vkFreeMemory)(self._handle, raw_memory, ptr::null());
        }
    }
    
    pub fn map_memory(&self, memory: &VkDeviceMemory, offset: usize, size: usize, flags: VkMemoryMapFlags, data: *mut *mut c_void) -> VkResult {
        unsafe {
            let raw_memory = vk_to_raw_value(memory);
            let raw_offset = vk_to_raw_value(&offset);
            let raw_size = vk_to_raw_value(&size);
            let raw_flags = vk_to_raw_value(&flags);
            let raw_data = data;
            let vk_result = ((&*self._fn_table).vkMapMemory)(self._handle, raw_memory, raw_offset, raw_size, raw_flags, raw_data);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn unmap_memory(&self, memory: &VkDeviceMemory) {
        unsafe {
            let raw_memory = vk_to_raw_value(memory);
            ((&*self._fn_table).vkUnmapMemory)(self._handle, raw_memory);
        }
    }
    
    pub fn flush_mapped_memory_ranges(&self, memory_ranges: &[VkMappedMemoryRange]) -> VkResult {
        unsafe {
            let raw_memory_range_count = memory_ranges.len() as u32;
            let raw_memory_ranges = new_ptr_vk_array(memory_ranges);
            let vk_result = ((&*self._fn_table).vkFlushMappedMemoryRanges)(self._handle, raw_memory_range_count, raw_memory_ranges);
            free_vk_ptr_array(raw_memory_range_count as usize, raw_memory_ranges);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn invalidate_mapped_memory_ranges(&self, memory_ranges: &[VkMappedMemoryRange]) -> VkResult {
        unsafe {
            let raw_memory_range_count = memory_ranges.len() as u32;
            let raw_memory_ranges = new_ptr_vk_array(memory_ranges);
            let vk_result = ((&*self._fn_table).vkInvalidateMappedMemoryRanges)(self._handle, raw_memory_range_count, raw_memory_ranges);
            free_vk_ptr_array(raw_memory_range_count as usize, raw_memory_ranges);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn get_memory_commitment(&self, memory: &VkDeviceMemory) -> usize {
        unsafe {
            let raw_memory = vk_to_raw_value(memory);
            let raw_committed_memory_in_bytes = &mut mem::uninitialized() as *mut u64;
            
            ((&*self._fn_table).vkGetDeviceMemoryCommitment)(self._handle, raw_memory, raw_committed_memory_in_bytes);
            
            let committed_memory_in_bytes = new_vk_value(raw_committed_memory_in_bytes);
            committed_memory_in_bytes
        }
    }
    
    pub fn create_fence(&self, create_info: &VkFenceCreateInfo) -> Result<VkFence, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_fence = &mut mem::uninitialized() as *mut RawVkFence;
            
            let vk_result = ((&*self._fn_table).vkCreateFence)(self._handle, raw_create_info, ptr::null(), raw_fence);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut fence = new_vk_value(raw_fence);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut fence, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(fence)
        }
    }
    
    pub fn reset_fences(&self, fences: &[&VkFence]) -> VkResult {
        unsafe {
            let raw_fence_count = fences.len() as u32;
            let raw_fences = new_ptr_vk_array_from_ref(fences);
            let vk_result = ((&*self._fn_table).vkResetFences)(self._handle, raw_fence_count, raw_fences);
            free_ptr(raw_fences);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn wait_for_fences(&self, fences: &[&VkFence], wait_all: bool, timeout: usize) -> VkResult {
        unsafe {
            let raw_fence_count = fences.len() as u32;
            let raw_fences = new_ptr_vk_array_from_ref(fences);
            let raw_wait_all = vk_to_raw_value(&wait_all);
            let raw_timeout = vk_to_raw_value(&timeout);
            let vk_result = ((&*self._fn_table).vkWaitForFences)(self._handle, raw_fence_count, raw_fences, raw_wait_all, raw_timeout);
            free_ptr(raw_fences);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn create_semaphore(&self, create_info: &VkSemaphoreCreateInfo) -> Result<VkSemaphore, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_semaphore = &mut mem::uninitialized() as *mut RawVkSemaphore;
            
            let vk_result = ((&*self._fn_table).vkCreateSemaphore)(self._handle, raw_create_info, ptr::null(), raw_semaphore);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut semaphore = new_vk_value(raw_semaphore);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut semaphore, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(semaphore)
        }
    }
    
    pub fn create_event(&self, create_info: &VkEventCreateInfo) -> Result<VkEvent, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_event = &mut mem::uninitialized() as *mut RawVkEvent;
            
            let vk_result = ((&*self._fn_table).vkCreateEvent)(self._handle, raw_create_info, ptr::null(), raw_event);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut event = new_vk_value(raw_event);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut event, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(event)
        }
    }
    
    pub fn create_query_pool(&self, create_info: &VkQueryPoolCreateInfo) -> Result<VkQueryPool, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_query_pool = &mut mem::uninitialized() as *mut RawVkQueryPool;
            
            let vk_result = ((&*self._fn_table).vkCreateQueryPool)(self._handle, raw_create_info, ptr::null(), raw_query_pool);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut query_pool = new_vk_value(raw_query_pool);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut query_pool, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(query_pool)
        }
    }
    
    pub fn create_buffer(&self, create_info: &VkBufferCreateInfo) -> Result<VkBuffer, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_buffer = &mut mem::uninitialized() as *mut RawVkBuffer;
            
            let vk_result = ((&*self._fn_table).vkCreateBuffer)(self._handle, raw_create_info, ptr::null(), raw_buffer);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut buffer = new_vk_value(raw_buffer);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut buffer, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(buffer)
        }
    }
    
    pub fn create_buffer_view(&self, create_info: &VkBufferViewCreateInfo) -> Result<VkBufferView, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_view = &mut mem::uninitialized() as *mut RawVkBufferView;
            
            let vk_result = ((&*self._fn_table).vkCreateBufferView)(self._handle, raw_create_info, ptr::null(), raw_view);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut view = new_vk_value(raw_view);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut view, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(view)
        }
    }
    
    pub fn create_image(&self, create_info: &VkImageCreateInfo) -> Result<VkImage, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_image = &mut mem::uninitialized() as *mut RawVkImage;
            
            let vk_result = ((&*self._fn_table).vkCreateImage)(self._handle, raw_create_info, ptr::null(), raw_image);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut image = new_vk_value(raw_image);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut image, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(image)
        }
    }
    
    pub fn create_image_view(&self, create_info: &VkImageViewCreateInfo) -> Result<VkImageView, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_view = &mut mem::uninitialized() as *mut RawVkImageView;
            
            let vk_result = ((&*self._fn_table).vkCreateImageView)(self._handle, raw_create_info, ptr::null(), raw_view);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut view = new_vk_value(raw_view);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut view, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(view)
        }
    }
    
    pub fn create_shader_module(&self, create_info: &VkShaderModuleCreateInfo) -> Result<VkShaderModule, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_shader_module = &mut mem::uninitialized() as *mut RawVkShaderModule;
            
            let vk_result = ((&*self._fn_table).vkCreateShaderModule)(self._handle, raw_create_info, ptr::null(), raw_shader_module);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut shader_module = new_vk_value(raw_shader_module);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut shader_module, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(shader_module)
        }
    }
    
    pub fn create_pipeline_cache(&self, create_info: &VkPipelineCacheCreateInfo) -> Result<VkPipelineCache, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_pipeline_cache = &mut mem::uninitialized() as *mut RawVkPipelineCache;
            
            let vk_result = ((&*self._fn_table).vkCreatePipelineCache)(self._handle, raw_create_info, ptr::null(), raw_pipeline_cache);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut pipeline_cache = new_vk_value(raw_pipeline_cache);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut pipeline_cache, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(pipeline_cache)
        }
    }
    
    pub fn create_graphics_pipelines(&self, pipeline_cache: Option<&VkPipelineCache>, create_infos: &[VkGraphicsPipelineCreateInfo]) -> Result<Vec<VkPipeline>, VkResult> {
        unsafe {
            let raw_pipeline_cache = if pipeline_cache.is_some() { vk_to_raw_value(pipeline_cache.unwrap()) } else { 0 };
            let raw_create_info_count = create_infos.len() as u32;
            let raw_create_infos = new_ptr_vk_array(create_infos);
            let raw_pipelines = malloc((raw_create_info_count as usize) * mem::size_of::<RawVkPipeline>()) as *mut RawVkPipeline;
            
            let vk_result = ((&*self._fn_table).vkCreateGraphicsPipelines)(self._handle, raw_pipeline_cache, raw_create_info_count, raw_create_infos, ptr::null(), raw_pipelines);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut pipelines = new_vk_array(raw_create_info_count, raw_pipelines);
            for elt in &mut pipelines { VkSetup::vk_setup(elt, self._fn_table, self._parent_instance, self._parent_device); }
            free_vk_ptr_array(raw_create_info_count as usize, raw_create_infos);
            free_ptr(raw_pipelines);
            Ok(pipelines)
        }
    }
    
    pub fn create_compute_pipelines(&self, pipeline_cache: Option<&VkPipelineCache>, create_infos: &[VkComputePipelineCreateInfo]) -> Result<Vec<VkPipeline>, VkResult> {
        unsafe {
            let raw_pipeline_cache = if pipeline_cache.is_some() { vk_to_raw_value(pipeline_cache.unwrap()) } else { 0 };
            let raw_create_info_count = create_infos.len() as u32;
            let raw_create_infos = new_ptr_vk_array(create_infos);
            let raw_pipelines = malloc((raw_create_info_count as usize) * mem::size_of::<RawVkPipeline>()) as *mut RawVkPipeline;
            
            let vk_result = ((&*self._fn_table).vkCreateComputePipelines)(self._handle, raw_pipeline_cache, raw_create_info_count, raw_create_infos, ptr::null(), raw_pipelines);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut pipelines = new_vk_array(raw_create_info_count, raw_pipelines);
            for elt in &mut pipelines { VkSetup::vk_setup(elt, self._fn_table, self._parent_instance, self._parent_device); }
            free_vk_ptr_array(raw_create_info_count as usize, raw_create_infos);
            free_ptr(raw_pipelines);
            Ok(pipelines)
        }
    }
    
    pub fn create_pipeline_layout(&self, create_info: &VkPipelineLayoutCreateInfo) -> Result<VkPipelineLayout, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_pipeline_layout = &mut mem::uninitialized() as *mut RawVkPipelineLayout;
            
            let vk_result = ((&*self._fn_table).vkCreatePipelineLayout)(self._handle, raw_create_info, ptr::null(), raw_pipeline_layout);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut pipeline_layout = new_vk_value(raw_pipeline_layout);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut pipeline_layout, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(pipeline_layout)
        }
    }
    
    pub fn create_sampler(&self, create_info: &VkSamplerCreateInfo) -> Result<VkSampler, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_sampler = &mut mem::uninitialized() as *mut RawVkSampler;
            
            let vk_result = ((&*self._fn_table).vkCreateSampler)(self._handle, raw_create_info, ptr::null(), raw_sampler);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut sampler = new_vk_value(raw_sampler);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut sampler, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(sampler)
        }
    }
    
    pub fn create_descriptor_set_layout(&self, create_info: &VkDescriptorSetLayoutCreateInfo) -> Result<VkDescriptorSetLayout, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_set_layout = &mut mem::uninitialized() as *mut RawVkDescriptorSetLayout;
            
            let vk_result = ((&*self._fn_table).vkCreateDescriptorSetLayout)(self._handle, raw_create_info, ptr::null(), raw_set_layout);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut set_layout = new_vk_value(raw_set_layout);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut set_layout, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(set_layout)
        }
    }
    
    pub fn create_descriptor_pool(&self, create_info: &VkDescriptorPoolCreateInfo) -> Result<VkDescriptorPool, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_descriptor_pool = &mut mem::uninitialized() as *mut RawVkDescriptorPool;
            
            let vk_result = ((&*self._fn_table).vkCreateDescriptorPool)(self._handle, raw_create_info, ptr::null(), raw_descriptor_pool);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut descriptor_pool = new_vk_value(raw_descriptor_pool);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut descriptor_pool, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(descriptor_pool)
        }
    }
    
    pub fn allocate_descriptor_sets(&self, allocate_info: &VkDescriptorSetAllocateInfo) -> Result<VkDescriptorSet, VkResult> {
        unsafe {
            let raw_allocate_info = new_ptr_vk_value(allocate_info);
            let raw_descriptor_sets = &mut mem::uninitialized() as *mut RawVkDescriptorSet;
            
            let vk_result = ((&*self._fn_table).vkAllocateDescriptorSets)(self._handle, raw_allocate_info, raw_descriptor_sets);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut descriptor_sets = new_vk_value(raw_descriptor_sets);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut descriptor_sets, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_allocate_info);
            Ok(descriptor_sets)
        }
    }
    
    pub fn update_descriptor_sets(&self, descriptor_writes: &[VkWriteDescriptorSet], descriptor_copies: &[VkCopyDescriptorSet]) {
        unsafe {
            let raw_descriptor_write_count = descriptor_writes.len() as u32;
            let raw_descriptor_writes = new_ptr_vk_array(descriptor_writes);
            let raw_descriptor_copy_count = descriptor_copies.len() as u32;
            let raw_descriptor_copies = new_ptr_vk_array(descriptor_copies);
            ((&*self._fn_table).vkUpdateDescriptorSets)(self._handle, raw_descriptor_write_count, raw_descriptor_writes, raw_descriptor_copy_count, raw_descriptor_copies);
            free_vk_ptr_array(raw_descriptor_write_count as usize, raw_descriptor_writes);
            free_vk_ptr_array(raw_descriptor_copy_count as usize, raw_descriptor_copies);
        }
    }
    
    pub fn create_framebuffer(&self, create_info: &VkFramebufferCreateInfo) -> Result<VkFramebuffer, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_framebuffer = &mut mem::uninitialized() as *mut RawVkFramebuffer;
            
            let vk_result = ((&*self._fn_table).vkCreateFramebuffer)(self._handle, raw_create_info, ptr::null(), raw_framebuffer);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut framebuffer = new_vk_value(raw_framebuffer);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut framebuffer, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(framebuffer)
        }
    }
    
    pub fn create_render_pass(&self, create_info: &VkRenderPassCreateInfo) -> Result<VkRenderPass, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_render_pass = &mut mem::uninitialized() as *mut RawVkRenderPass;
            
            let vk_result = ((&*self._fn_table).vkCreateRenderPass)(self._handle, raw_create_info, ptr::null(), raw_render_pass);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut render_pass = new_vk_value(raw_render_pass);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut render_pass, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(render_pass)
        }
    }
    
    pub fn create_command_pool(&self, create_info: &VkCommandPoolCreateInfo) -> Result<VkCommandPool, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_command_pool = &mut mem::uninitialized() as *mut RawVkCommandPool;
            
            let vk_result = ((&*self._fn_table).vkCreateCommandPool)(self._handle, raw_create_info, ptr::null(), raw_command_pool);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut command_pool = new_vk_value(raw_command_pool);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut command_pool, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(command_pool)
        }
    }
    
    pub fn allocate_command_buffers(&self, allocate_info: &VkCommandBufferAllocateInfo) -> Result<VkCommandBuffer, VkResult> {
        unsafe {
            let raw_allocate_info = new_ptr_vk_value(allocate_info);
            let raw_command_buffers = &mut mem::uninitialized() as *mut RawVkCommandBuffer;
            
            let vk_result = ((&*self._fn_table).vkAllocateCommandBuffers)(self._handle, raw_allocate_info, raw_command_buffers);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut command_buffers = new_vk_value(raw_command_buffers);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut command_buffers, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_allocate_info);
            Ok(command_buffers)
        }
    }
    
    pub fn bind_buffer_memory_2(&self, bind_infos: &[VkBindBufferMemoryInfo]) -> VkResult {
        unsafe {
            let raw_bind_info_count = bind_infos.len() as u32;
            let raw_bind_infos = new_ptr_vk_array(bind_infos);
            let vk_result = ((&*self._fn_table).vkBindBufferMemory2)(self._handle, raw_bind_info_count, raw_bind_infos);
            free_vk_ptr_array(raw_bind_info_count as usize, raw_bind_infos);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn bind_image_memory_2(&self, bind_infos: &[VkBindImageMemoryInfo]) -> VkResult {
        unsafe {
            let raw_bind_info_count = bind_infos.len() as u32;
            let raw_bind_infos = new_ptr_vk_array(bind_infos);
            let vk_result = ((&*self._fn_table).vkBindImageMemory2)(self._handle, raw_bind_info_count, raw_bind_infos);
            free_vk_ptr_array(raw_bind_info_count as usize, raw_bind_infos);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn get_group_peer_memory_features(&self, heap_index: usize, local_device_index: usize, remote_device_index: usize) -> VkPeerMemoryFeatureFlags {
        unsafe {
            let raw_heap_index = vk_to_raw_value(&heap_index);
            let raw_local_device_index = vk_to_raw_value(&local_device_index);
            let raw_remote_device_index = vk_to_raw_value(&remote_device_index);
            let raw_peer_memory_features = &mut mem::uninitialized() as *mut RawVkPeerMemoryFeatureFlags;
            
            ((&*self._fn_table).vkGetDeviceGroupPeerMemoryFeatures)(self._handle, raw_heap_index, raw_local_device_index, raw_remote_device_index, raw_peer_memory_features);
            
            let peer_memory_features = new_vk_value(raw_peer_memory_features);
            peer_memory_features
        }
    }
    
    pub fn get_image_memory_requirements_2(&self, info: &VkImageMemoryRequirementsInfo2) -> VkMemoryRequirements2 {
        unsafe {
            let raw_info = new_ptr_vk_value(info);
            let raw_memory_requirements = &mut mem::uninitialized() as *mut RawVkMemoryRequirements2;
            
            ((&*self._fn_table).vkGetImageMemoryRequirements2)(self._handle, raw_info, raw_memory_requirements);
            
            let mut memory_requirements = new_vk_value(raw_memory_requirements);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut memory_requirements, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_info);
            RawVkMemoryRequirements2::vk_free(raw_memory_requirements.as_mut().unwrap());
            memory_requirements
        }
    }
    
    pub fn get_buffer_memory_requirements_2(&self, info: &VkBufferMemoryRequirementsInfo2) -> VkMemoryRequirements2 {
        unsafe {
            let raw_info = new_ptr_vk_value(info);
            let raw_memory_requirements = &mut mem::uninitialized() as *mut RawVkMemoryRequirements2;
            
            ((&*self._fn_table).vkGetBufferMemoryRequirements2)(self._handle, raw_info, raw_memory_requirements);
            
            let mut memory_requirements = new_vk_value(raw_memory_requirements);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut memory_requirements, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_info);
            RawVkMemoryRequirements2::vk_free(raw_memory_requirements.as_mut().unwrap());
            memory_requirements
        }
    }
    
    pub fn get_image_sparse_memory_requirements_2(&self, info: &VkImageSparseMemoryRequirementsInfo2) -> Vec<VkSparseImageMemoryRequirements2> {
        unsafe {
            let raw_info = new_ptr_vk_value(info);
            let mut raw_sparse_memory_requirements : *mut RawVkSparseImageMemoryRequirements2 = ptr::null_mut();
            let raw_sparse_memory_requirement_count = &mut mem::uninitialized() as *mut u32;
            ((&*self._fn_table).vkGetImageSparseMemoryRequirements2)(self._handle, raw_info, raw_sparse_memory_requirement_count, raw_sparse_memory_requirements);
            raw_sparse_memory_requirements = malloc((*raw_sparse_memory_requirement_count as usize) * mem::size_of::<RawVkSparseImageMemoryRequirements2>()) as *mut RawVkSparseImageMemoryRequirements2;
            
            ((&*self._fn_table).vkGetImageSparseMemoryRequirements2)(self._handle, raw_info, raw_sparse_memory_requirement_count, raw_sparse_memory_requirements);
            
            let mut sparse_memory_requirements = new_vk_array(*raw_sparse_memory_requirement_count, raw_sparse_memory_requirements);
            for elt in &mut sparse_memory_requirements { VkSetup::vk_setup(elt, self._fn_table, self._parent_instance, self._parent_device); }
            free_vk_ptr(raw_info);
            free_vk_ptr_array(*raw_sparse_memory_requirement_count as usize, raw_sparse_memory_requirements);
            sparse_memory_requirements
        }
    }
    
    pub fn get_queue_2(&self, queue_info: &VkDeviceQueueInfo2) -> VkQueue {
        unsafe {
            let raw_queue_info = new_ptr_vk_value(queue_info);
            let raw_queue = &mut mem::uninitialized() as *mut RawVkQueue;
            
            ((&*self._fn_table).vkGetDeviceQueue2)(self._handle, raw_queue_info, raw_queue);
            
            let mut queue = new_vk_value(raw_queue);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut queue, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_queue_info);
            queue
        }
    }
    
    pub fn create_sampler_ycbcr_conversion(&self, create_info: &VkSamplerYcbcrConversionCreateInfo) -> Result<VkSamplerYcbcrConversion, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_ycbcr_conversion = &mut mem::uninitialized() as *mut RawVkSamplerYcbcrConversion;
            
            let vk_result = ((&*self._fn_table).vkCreateSamplerYcbcrConversion)(self._handle, raw_create_info, ptr::null(), raw_ycbcr_conversion);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut ycbcr_conversion = new_vk_value(raw_ycbcr_conversion);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut ycbcr_conversion, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(ycbcr_conversion)
        }
    }
    
    pub fn create_descriptor_update_template(&self, create_info: &VkDescriptorUpdateTemplateCreateInfo) -> Result<VkDescriptorUpdateTemplate, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_descriptor_update_template = &mut mem::uninitialized() as *mut RawVkDescriptorUpdateTemplate;
            
            let vk_result = ((&*self._fn_table).vkCreateDescriptorUpdateTemplate)(self._handle, raw_create_info, ptr::null(), raw_descriptor_update_template);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut descriptor_update_template = new_vk_value(raw_descriptor_update_template);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut descriptor_update_template, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(descriptor_update_template)
        }
    }
    
    pub fn update_descriptor_set_with_template(&self, descriptor_set: &VkDescriptorSet, descriptor_update_template: &VkDescriptorUpdateTemplate, data: &c_void) {
        unsafe {
            let raw_descriptor_set = vk_to_raw_value(descriptor_set);
            let raw_descriptor_update_template = vk_to_raw_value(descriptor_update_template);
            let raw_data = data as *const c_void;
            ((&*self._fn_table).vkUpdateDescriptorSetWithTemplate)(self._handle, raw_descriptor_set, raw_descriptor_update_template, raw_data);
        }
    }
    
    pub fn get_descriptor_set_layout_support(&self, create_info: &VkDescriptorSetLayoutCreateInfo) -> VkDescriptorSetLayoutSupport {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_support = &mut mem::uninitialized() as *mut RawVkDescriptorSetLayoutSupport;
            
            ((&*self._fn_table).vkGetDescriptorSetLayoutSupport)(self._handle, raw_create_info, raw_support);
            
            let mut support = new_vk_value(raw_support);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut support, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            RawVkDescriptorSetLayoutSupport::vk_free(raw_support.as_mut().unwrap());
            support
        }
    }
    
    pub fn create_swapchain(&self, create_info: &khr::VkSwapchainCreateInfo) -> Result<khr::VkSwapchain, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_swapchain = &mut mem::uninitialized() as *mut khr::RawVkSwapchain;
            
            let vk_result = ((&*self._fn_table).vkCreateSwapchainKHR)(self._handle, raw_create_info, ptr::null(), raw_swapchain);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut swapchain = new_vk_value(raw_swapchain);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut swapchain, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(swapchain)
        }
    }
    
    pub fn get_group_present_capabilities(&self) -> Result<khr::VkDeviceGroupPresentCapabilities, VkResult> {
        unsafe {
            let raw_device_group_present_capabilities = &mut mem::uninitialized() as *mut khr::RawVkDeviceGroupPresentCapabilities;
            
            let vk_result = ((&*self._fn_table).vkGetDeviceGroupPresentCapabilitiesKHR)(self._handle, raw_device_group_present_capabilities);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut device_group_present_capabilities = new_vk_value(raw_device_group_present_capabilities);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut device_group_present_capabilities, fn_table, parent_instance, parent_device);
            khr::RawVkDeviceGroupPresentCapabilities::vk_free(raw_device_group_present_capabilities.as_mut().unwrap());
            Ok(device_group_present_capabilities)
        }
    }
    
    pub fn get_group_surface_present_modes(&self, surface: &khr::VkSurface) -> Result<khr::VkDeviceGroupPresentModeFlags, VkResult> {
        unsafe {
            let raw_surface = vk_to_raw_value(surface);
            let raw_modes = &mut mem::uninitialized() as *mut khr::RawVkDeviceGroupPresentModeFlags;
            
            let vk_result = ((&*self._fn_table).vkGetDeviceGroupSurfacePresentModesKHR)(self._handle, raw_surface, raw_modes);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let modes = new_vk_value(raw_modes);
            Ok(modes)
        }
    }
    
    pub fn acquire_next_image_2(&self, acquire_info: &khr::VkAcquireNextImageInfo) -> Result<usize, VkResult> {
        unsafe {
            let raw_acquire_info = new_ptr_vk_value(acquire_info);
            let raw_image_index = &mut mem::uninitialized() as *mut u32;
            
            let vk_result = ((&*self._fn_table).vkAcquireNextImage2KHR)(self._handle, raw_acquire_info, raw_image_index);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let image_index = new_vk_value(raw_image_index);
            free_vk_ptr(raw_acquire_info);
            Ok(image_index)
        }
    }
    
    pub fn create_shared_swapchains(&self, create_infos: &[khr::VkSwapchainCreateInfo]) -> Result<Vec<khr::VkSwapchain>, VkResult> {
        unsafe {
            let raw_swapchain_count = create_infos.len() as u32;
            let raw_create_infos = new_ptr_vk_array(create_infos);
            let raw_swapchains = malloc((raw_swapchain_count as usize) * mem::size_of::<khr::RawVkSwapchain>()) as *mut khr::RawVkSwapchain;
            
            let vk_result = ((&*self._fn_table).vkCreateSharedSwapchainsKHR)(self._handle, raw_swapchain_count, raw_create_infos, ptr::null(), raw_swapchains);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut swapchains = new_vk_array(raw_swapchain_count, raw_swapchains);
            for elt in &mut swapchains { VkSetup::vk_setup(elt, self._fn_table, self._parent_instance, self._parent_device); }
            free_vk_ptr_array(raw_swapchain_count as usize, raw_create_infos);
            free_ptr(raw_swapchains);
            Ok(swapchains)
        }
    }
    
    pub fn get_memory_fd(&self, get_fd_info: &khr::VkMemoryGetFdInfo) -> Result<i32, VkResult> {
        unsafe {
            let raw_get_fd_info = new_ptr_vk_value(get_fd_info);
            let raw_fd = &mut mem::uninitialized() as *mut i32;
            
            let vk_result = ((&*self._fn_table).vkGetMemoryFdKHR)(self._handle, raw_get_fd_info, raw_fd);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let fd = *raw_fd;
            free_vk_ptr(raw_get_fd_info);
            Ok(fd)
        }
    }
    
    pub fn get_memory_fd_properties(&self, handle_type: VkExternalMemoryHandleTypeFlags, fd: i32) -> Result<khr::VkMemoryFdProperties, VkResult> {
        unsafe {
            let raw_handle_type = vk_to_raw_value(&handle_type);
            let raw_fd = fd;
            let raw_memory_fd_properties = &mut mem::uninitialized() as *mut khr::RawVkMemoryFdProperties;
            
            let vk_result = ((&*self._fn_table).vkGetMemoryFdPropertiesKHR)(self._handle, raw_handle_type, raw_fd, raw_memory_fd_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut memory_fd_properties = new_vk_value(raw_memory_fd_properties);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut memory_fd_properties, fn_table, parent_instance, parent_device);
            khr::RawVkMemoryFdProperties::vk_free(raw_memory_fd_properties.as_mut().unwrap());
            Ok(memory_fd_properties)
        }
    }
    
    pub fn import_semaphore_fd(&self, import_semaphore_fd_info: &khr::VkImportSemaphoreFdInfo) -> VkResult {
        unsafe {
            let raw_import_semaphore_fd_info = new_ptr_vk_value(import_semaphore_fd_info);
            let vk_result = ((&*self._fn_table).vkImportSemaphoreFdKHR)(self._handle, raw_import_semaphore_fd_info);
            free_vk_ptr(raw_import_semaphore_fd_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn get_semaphore_fd(&self, get_fd_info: &khr::VkSemaphoreGetFdInfo) -> Result<i32, VkResult> {
        unsafe {
            let raw_get_fd_info = new_ptr_vk_value(get_fd_info);
            let raw_fd = &mut mem::uninitialized() as *mut i32;
            
            let vk_result = ((&*self._fn_table).vkGetSemaphoreFdKHR)(self._handle, raw_get_fd_info, raw_fd);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let fd = *raw_fd;
            free_vk_ptr(raw_get_fd_info);
            Ok(fd)
        }
    }
    
    pub fn create_render_pass_2(&self, create_info: &khr::VkRenderPassCreateInfo2) -> Result<VkRenderPass, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_render_pass = &mut mem::uninitialized() as *mut RawVkRenderPass;
            
            let vk_result = ((&*self._fn_table).vkCreateRenderPass2KHR)(self._handle, raw_create_info, ptr::null(), raw_render_pass);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut render_pass = new_vk_value(raw_render_pass);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut render_pass, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(render_pass)
        }
    }
    
    pub fn import_fence_fd(&self, import_fence_fd_info: &khr::VkImportFenceFdInfo) -> VkResult {
        unsafe {
            let raw_import_fence_fd_info = new_ptr_vk_value(import_fence_fd_info);
            let vk_result = ((&*self._fn_table).vkImportFenceFdKHR)(self._handle, raw_import_fence_fd_info);
            free_vk_ptr(raw_import_fence_fd_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn get_fence_fd(&self, get_fd_info: &khr::VkFenceGetFdInfo) -> Result<i32, VkResult> {
        unsafe {
            let raw_get_fd_info = new_ptr_vk_value(get_fd_info);
            let raw_fd = &mut mem::uninitialized() as *mut i32;
            
            let vk_result = ((&*self._fn_table).vkGetFenceFdKHR)(self._handle, raw_get_fd_info, raw_fd);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let fd = *raw_fd;
            free_vk_ptr(raw_get_fd_info);
            Ok(fd)
        }
    }
    
    pub fn debug_marker_set_object_tag(&self, tag_info: &ext::VkDebugMarkerObjectTagInfo) -> VkResult {
        unsafe {
            let raw_tag_info = new_ptr_vk_value(tag_info);
            let vk_result = ((&*self._fn_table).vkDebugMarkerSetObjectTagEXT)(self._handle, raw_tag_info);
            free_vk_ptr(raw_tag_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn debug_marker_set_object_name(&self, name_info: &ext::VkDebugMarkerObjectNameInfo) -> VkResult {
        unsafe {
            let raw_name_info = new_ptr_vk_value(name_info);
            let vk_result = ((&*self._fn_table).vkDebugMarkerSetObjectNameEXT)(self._handle, raw_name_info);
            free_vk_ptr(raw_name_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn create_indirect_commands_layout(&self, create_info: &nvx::VkIndirectCommandsLayoutCreateInfo) -> Result<nvx::VkIndirectCommandsLayout, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_indirect_commands_layout = &mut mem::uninitialized() as *mut nvx::RawVkIndirectCommandsLayout;
            
            let vk_result = ((&*self._fn_table).vkCreateIndirectCommandsLayoutNVX)(self._handle, raw_create_info, ptr::null(), raw_indirect_commands_layout);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut indirect_commands_layout = new_vk_value(raw_indirect_commands_layout);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut indirect_commands_layout, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(indirect_commands_layout)
        }
    }
    
    pub fn create_object_table(&self, create_info: &nvx::VkObjectTableCreateInfo) -> Result<nvx::VkObjectTable, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_object_table = &mut mem::uninitialized() as *mut nvx::RawVkObjectTable;
            
            let vk_result = ((&*self._fn_table).vkCreateObjectTableNVX)(self._handle, raw_create_info, ptr::null(), raw_object_table);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut object_table = new_vk_value(raw_object_table);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut object_table, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(object_table)
        }
    }
    
    pub fn display_power_control(&self, display: &khr::VkDisplay, display_power_info: &ext::VkDisplayPowerInfo) -> VkResult {
        unsafe {
            let raw_display = vk_to_raw_value(display);
            let raw_display_power_info = new_ptr_vk_value(display_power_info);
            let vk_result = ((&*self._fn_table).vkDisplayPowerControlEXT)(self._handle, raw_display, raw_display_power_info);
            free_vk_ptr(raw_display_power_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn register_event(&self, device_event_info: &ext::VkDeviceEventInfo) -> Result<VkFence, VkResult> {
        unsafe {
            let raw_device_event_info = new_ptr_vk_value(device_event_info);
            let raw_fence = &mut mem::uninitialized() as *mut RawVkFence;
            
            let vk_result = ((&*self._fn_table).vkRegisterDeviceEventEXT)(self._handle, raw_device_event_info, ptr::null(), raw_fence);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut fence = new_vk_value(raw_fence);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut fence, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_device_event_info);
            Ok(fence)
        }
    }
    
    pub fn register_display_event(&self, display: &khr::VkDisplay, display_event_info: &ext::VkDisplayEventInfo) -> Result<VkFence, VkResult> {
        unsafe {
            let raw_display = vk_to_raw_value(display);
            let raw_display_event_info = new_ptr_vk_value(display_event_info);
            let raw_fence = &mut mem::uninitialized() as *mut RawVkFence;
            
            let vk_result = ((&*self._fn_table).vkRegisterDisplayEventEXT)(self._handle, raw_display, raw_display_event_info, ptr::null(), raw_fence);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut fence = new_vk_value(raw_fence);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut fence, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_display_event_info);
            Ok(fence)
        }
    }
    
    pub fn set_hdr_metadata(&self, swapchains: &[&khr::VkSwapchain], metadata: &[ext::VkHdrMetadata]) {
        unsafe {
            let raw_swapchain_count = cmp::max(swapchains.len(), metadata.len()) as u32;
            let raw_swapchains = new_ptr_vk_array_from_ref(swapchains);
            let raw_metadata = new_ptr_vk_array(metadata);
            ((&*self._fn_table).vkSetHdrMetadataEXT)(self._handle, raw_swapchain_count, raw_swapchains, raw_metadata);
            free_ptr(raw_swapchains);
            free_vk_ptr_array(raw_swapchain_count as usize, raw_metadata);
        }
    }
    
    pub fn set_debug_utils_object_name(&self, name_info: &ext::VkDebugUtilsObjectNameInfo) -> VkResult {
        unsafe {
            let raw_name_info = new_ptr_vk_value(name_info);
            let vk_result = ((&*self._fn_table).vkSetDebugUtilsObjectNameEXT)(self._handle, raw_name_info);
            free_vk_ptr(raw_name_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn set_debug_utils_object_tag(&self, tag_info: &ext::VkDebugUtilsObjectTagInfo) -> VkResult {
        unsafe {
            let raw_tag_info = new_ptr_vk_value(tag_info);
            let vk_result = ((&*self._fn_table).vkSetDebugUtilsObjectTagEXT)(self._handle, raw_tag_info);
            free_vk_ptr(raw_tag_info);
            RawVkResult::vk_to_wrapped(&vk_result)
        }
    }
    
    pub fn create_validation_cache(&self, create_info: &ext::VkValidationCacheCreateInfo) -> Result<ext::VkValidationCache, VkResult> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(create_info);
            let raw_validation_cache = &mut mem::uninitialized() as *mut ext::RawVkValidationCache;
            
            let vk_result = ((&*self._fn_table).vkCreateValidationCacheEXT)(self._handle, raw_create_info, ptr::null(), raw_validation_cache);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut validation_cache = new_vk_value(raw_validation_cache);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut validation_cache, fn_table, parent_instance, parent_device);
            free_vk_ptr(raw_create_info);
            Ok(validation_cache)
        }
    }
    
    pub fn get_memory_host_pointer_properties(&self, handle_type: VkExternalMemoryHandleTypeFlags, host_pointer: &c_void) -> Result<ext::VkMemoryHostPointerProperties, VkResult> {
        unsafe {
            let raw_handle_type = vk_to_raw_value(&handle_type);
            let raw_host_pointer = host_pointer as *const c_void;
            let raw_memory_host_pointer_properties = &mut mem::uninitialized() as *mut ext::RawVkMemoryHostPointerProperties;
            
            let vk_result = ((&*self._fn_table).vkGetMemoryHostPointerPropertiesEXT)(self._handle, raw_handle_type, raw_host_pointer, raw_memory_host_pointer_properties);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            
            let mut memory_host_pointer_properties = new_vk_value(raw_memory_host_pointer_properties);
            let fn_table = self._fn_table;
            let parent_instance = self._parent_instance;
            let parent_device = self._parent_device;
            VkSetup::vk_setup(&mut memory_host_pointer_properties, fn_table, parent_instance, parent_device);
            ext::RawVkMemoryHostPointerProperties::vk_free(raw_memory_host_pointer_properties.as_mut().unwrap());
            Ok(memory_host_pointer_properties)
        }
    }
}