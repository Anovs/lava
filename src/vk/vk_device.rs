// Generated by `scripts/generate_vk.js`

use vk::*;
use std::os::raw::c_char;
use std::ops::Drop;
use std::vec::Vec;
use std::ptr::null;
use libc::c_void;
use glfw::*;

pub type RawVkDevice = RawVkHandle;

#[derive(Debug)]
pub struct VkDevice {
    _handle: RawVkDevice,
}

impl VkDevice {
    
    pub fn handle(&self) -> RawVkDevice {
        self._handle
    }
    
    pub fn new(physical_device: &VkPhysicalDevice, create_info: &VkDeviceCreateInfo) -> Result<VkDevice, VkResult> {
        unsafe {
            let physical_device_handle = physical_device.handle();
            let mut raw_create_info = RawVkDeviceCreateInfo::vk_from(create_info);
            let raw_create_info_ptr = &mut raw_create_info as *mut RawVkDeviceCreateInfo;
            vk_call_retrieve_single(
                |ptr| vkCreateDevice(physical_device_handle, raw_create_info_ptr, null(), ptr),
                |device : &mut VkDevice| {  }
            )
        }
    }
    
    pub fn get_queue(&self, queue_family_index: usize, queue_index: usize) -> VkQueue {
        VkQueue::get(self, queue_family_index, queue_index)
    }
    
    pub fn create_buffer(&self, create_info: &VkBufferCreateInfo) -> Result<VkBuffer, VkResult> {
        VkBuffer::new(self, create_info)
    }
    
    pub fn create_swapchain(&self, create_info: &VkSwapchainCreateInfo) -> Result<VkSwapchain, VkResult> {
        VkSwapchain::new(self, create_info)
    }
    
    pub fn create_image_view(&self, create_info: &VkImageViewCreateInfo) -> Result<VkImageView, VkResult> {
        VkImageView::new(self, create_info)
    }
    
    pub fn create_shader_module(&self, create_info: &VkShaderModuleCreateInfo) -> Result<VkShaderModule, VkResult> {
        VkShaderModule::new(self, create_info)
    }
    
    pub fn create_pipeline_layout(&self, create_info: &VkPipelineLayoutCreateInfo) -> Result<VkPipelineLayout, VkResult> {
        VkPipelineLayout::new(self, create_info)
    }
}

impl VkFrom<VkDevice> for RawVkDevice {
    
    fn vk_from(value: &VkDevice) -> Self {
        value._handle
    }
}

impl VkFrom<RawVkDevice> for VkDevice {
    
    fn vk_from(value: &RawVkDevice) -> Self {
        Self {
            _handle: *value,
        }
    }
}

impl Drop for VkDevice {
    
    fn drop(&mut self) {
        unsafe {
            vkDestroyDevice(self._handle, null());
        }
    }
}

extern {
    fn vkDestroyDevice(device: RawVkDevice, p_allocator: *const c_void);
    fn vkCreateDevice(physical_device: RawVkPhysicalDevice, p_create_info: *const RawVkDeviceCreateInfo, p_allocator: *const c_void, p_device: *mut RawVkDevice)-> RawVkResult;
}