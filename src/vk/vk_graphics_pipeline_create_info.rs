// Generated by `scripts/generate_vk.js`

use std::os::raw::c_char;
use std::ops::Deref;
use std::ptr;
use std::cmp;
use std::mem;
use utils::c_bindings::*;
use utils::vk_convert::*;
use utils::vk_null::*;
use utils::vk_ptr::*;
use utils::vk_traits::*;
use vk::vk_instance_function_table::*;
use vk::vk_instance::*;
use vk::vk_device::*;
use vk::vk_structure_type::*;
use vk::vk_pipeline_create_flags::*;
use vk::vk_pipeline_shader_stage_create_info::*;
use vk::vk_pipeline_vertex_input_state_create_info::*;
use vk::vk_pipeline_input_assembly_state_create_info::*;
use vk::vk_pipeline_tessellation_state_create_info::*;
use vk::vk_pipeline_viewport_state_create_info::*;
use vk::vk_pipeline_rasterization_state_create_info::*;
use vk::vk_pipeline_multisample_state_create_info::*;
use vk::vk_pipeline_depth_stencil_state_create_info::*;
use vk::vk_pipeline_color_blend_state_create_info::*;
use vk::vk_pipeline_dynamic_state_create_info::*;
use vk::vk_pipeline_layout::*;
use vk::vk_render_pass::*;
use vk::vk_pipeline::*;

#[repr(C)]
pub struct RawVkGraphicsPipelineCreateInfo {
    pub s_type: RawVkStructureType,
    pub next: *const c_void,
    pub flags: RawVkPipelineCreateFlags,
    pub stage_count: u32,
    pub stages: *mut RawVkPipelineShaderStageCreateInfo,
    pub vertex_input_state: *mut RawVkPipelineVertexInputStateCreateInfo,
    pub input_assembly_state: *mut RawVkPipelineInputAssemblyStateCreateInfo,
    pub tessellation_state: *mut RawVkPipelineTessellationStateCreateInfo,
    pub viewport_state: *mut RawVkPipelineViewportStateCreateInfo,
    pub rasterization_state: *mut RawVkPipelineRasterizationStateCreateInfo,
    pub multisample_state: *mut RawVkPipelineMultisampleStateCreateInfo,
    pub depth_stencil_state: *mut RawVkPipelineDepthStencilStateCreateInfo,
    pub color_blend_state: *mut RawVkPipelineColorBlendStateCreateInfo,
    pub dynamic_state: *mut RawVkPipelineDynamicStateCreateInfo,
    pub layout: RawVkPipelineLayout,
    pub render_pass: RawVkRenderPass,
    pub subpass: u32,
    pub base_pipeline_handle: RawVkPipeline,
    pub base_pipeline_index: i32,
}

#[derive(Debug, Clone)]
pub struct VkGraphicsPipelineCreateInfo<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y>
    where
        'b: 'a,
        'c: 'a,
        'd: 'a,
        'e: 'd,
        'f: 'd,
        'h: 'g,
        'i: 'g,
        'm: 'l,
        'n: 'l,
        'q: 'p,
        't: 's,
        'v: 'u,
{
    pub flags: VkPipelineCreateFlags,
    pub stages: &'a [VkPipelineShaderStageCreateInfo<'b, 'c, 'd, 'e, 'f>],
    pub vertex_input_state: &'g VkPipelineVertexInputStateCreateInfo<'h, 'i>,
    pub input_assembly_state: &'j VkPipelineInputAssemblyStateCreateInfo,
    pub tessellation_state: Option<&'k VkPipelineTessellationStateCreateInfo>,
    pub viewport_state: Option<&'l VkPipelineViewportStateCreateInfo<'m, 'n>>,
    pub rasterization_state: &'o VkPipelineRasterizationStateCreateInfo,
    pub multisample_state: Option<&'p VkPipelineMultisampleStateCreateInfo<'q>>,
    pub depth_stencil_state: Option<&'r VkPipelineDepthStencilStateCreateInfo>,
    pub color_blend_state: Option<&'s VkPipelineColorBlendStateCreateInfo<'t>>,
    pub dynamic_state: Option<&'u VkPipelineDynamicStateCreateInfo<'v>>,
    pub layout: &'w VkPipelineLayout,
    pub render_pass: &'x VkRenderPass,
    pub subpass: usize,
    pub base_pipeline_handle: Option<&'y VkPipeline>,
    pub base_pipeline_index: isize,
}

impl<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y> VkWrappedType<RawVkGraphicsPipelineCreateInfo> for VkGraphicsPipelineCreateInfo<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y>
    where
        'b: 'a,
        'c: 'a,
        'd: 'a,
        'e: 'd,
        'f: 'd,
        'h: 'g,
        'i: 'g,
        'm: 'l,
        'n: 'l,
        'q: 'p,
        't: 's,
        'v: 'u,
{
    fn vk_to_raw(src: &VkGraphicsPipelineCreateInfo, dst: &mut RawVkGraphicsPipelineCreateInfo) {
        dst.s_type = vk_to_raw_value(&VkStructureType::GraphicsPipelineCreateInfo);
        dst.next = ptr::null();
        dst.flags = vk_to_raw_value(&src.flags);
        dst.stage_count = src.stages.len() as u32;
        dst.stages = new_ptr_vk_array(src.stages);
        dst.vertex_input_state = new_ptr_vk_value(src.vertex_input_state);
        dst.input_assembly_state = new_ptr_vk_value(src.input_assembly_state);
        dst.tessellation_state = new_ptr_vk_value_checked(src.tessellation_state);
        dst.viewport_state = new_ptr_vk_value_checked(src.viewport_state);
        dst.rasterization_state = new_ptr_vk_value(src.rasterization_state);
        dst.multisample_state = new_ptr_vk_value_checked(src.multisample_state);
        dst.depth_stencil_state = new_ptr_vk_value_checked(src.depth_stencil_state);
        dst.color_blend_state = new_ptr_vk_value_checked(src.color_blend_state);
        dst.dynamic_state = new_ptr_vk_value_checked(src.dynamic_state);
        dst.layout = vk_to_raw_value(src.layout);
        dst.render_pass = vk_to_raw_value(src.render_pass);
        dst.subpass = vk_to_raw_value(&src.subpass);
        dst.base_pipeline_handle = if src.base_pipeline_handle.is_some() { vk_to_raw_value(src.base_pipeline_handle.unwrap()) } else { 0 };
        dst.base_pipeline_index = vk_to_raw_value(&src.base_pipeline_index);
    }
}

impl Default for VkGraphicsPipelineCreateInfo<'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static> {
    fn default() -> VkGraphicsPipelineCreateInfo<'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static, 'static> {
        VkGraphicsPipelineCreateInfo {
            flags: VkPipelineCreateFlags::default(),
            stages: &[],
            vertex_input_state: vk_null_ref(),
            input_assembly_state: vk_null_ref(),
            tessellation_state: None,
            viewport_state: None,
            rasterization_state: vk_null_ref(),
            multisample_state: None,
            depth_stencil_state: None,
            color_blend_state: None,
            dynamic_state: None,
            layout: vk_null_ref(),
            render_pass: vk_null_ref(),
            subpass: 0,
            base_pipeline_handle: None,
            base_pipeline_index: 0,
        }
    }
}

impl<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y> VkSetup for VkGraphicsPipelineCreateInfo<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y>
    where
        'b: 'a,
        'c: 'a,
        'd: 'a,
        'e: 'd,
        'f: 'd,
        'h: 'g,
        'i: 'g,
        'm: 'l,
        'n: 'l,
        'q: 'p,
        't: 's,
        'v: 'u,
{
    fn vk_setup(&mut self, fn_table: *mut VkInstanceFunctionTable, instance: RawVkInstance, device: RawVkDevice) {
        
    }
}

impl VkFree for RawVkGraphicsPipelineCreateInfo {
    fn vk_free(&mut self) {
        free_vk_ptr_array(self.stage_count as usize, self.stages);
        free_vk_ptr(self.vertex_input_state);
        free_vk_ptr(self.input_assembly_state);
        free_vk_ptr(self.tessellation_state);
        free_vk_ptr(self.viewport_state);
        free_vk_ptr(self.rasterization_state);
        free_vk_ptr(self.multisample_state);
        free_vk_ptr(self.depth_stencil_state);
        free_vk_ptr(self.color_blend_state);
        free_vk_ptr(self.dynamic_state);
    }
}