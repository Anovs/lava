use vk::VkHandler;

type VkInstance = VkHandler;
type VkPhysicalDevice = VkHandler;
type VkDevice = VkHandler;
type VkQueue = VkHandler;
type VkSemaphore = VkHandler;
type VkCommandBuffer = VkHandler;
type VkFence = VkHandler;
type VkDeviceMemory = VkHandler;
type VkBuffer = VkHandler;
type VkImage = VkHandler;
type VkEvent = VkHandler;
type VkQueryPool = VkHandler;
type VkBufferView = VkHandler;
type VkImageView = VkHandler;
type VkShaderModule = VkHandler;
type VkPipelineCache = VkHandler;
type VkPipelineLayout = VkHandler;
type VkRenderPass = VkHandler;
type VkPipeline = VkHandler;
type VkDescriptorSetLayout = VkHandler;
type VkSampler = VkHandler;
type VkDescriptorPool = VkHandler;
type VkDescriptorSet = VkHandler;
type VkFramebuffer = VkHandler;
type VkCommandPool = VkHandler;
type VkSamplerYcbcrConversion = VkHandler;
type VkDescriptorUpdateTemplate = VkHandler;
type VkSurfaceKHR = VkHandler;
type VkSwapchainKHR = VkHandler;
type VkDisplayKHR = VkHandler;
type VkDisplayModeKHR = VkHandler;
type VkDebugReportCallbackEXT = VkHandler;
type VkObjectTableNVX = VkHandler;
type VkIndirectCommandsLayoutNVX = VkHandler;
type VkDebugUtilsMessengerEXT = VkHandler;
type VkValidationCacheEXT = VkHandler;