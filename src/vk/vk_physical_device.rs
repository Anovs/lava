// Generated by `scripts/generate_vk.js`

use vk::*;
use std::os::raw::c_char;
use std::vec::Vec;
use std::ptr::null;
use libc::c_void;

pub type RawVkPhysicalDevice = RawVkHandle;

#[derive(Debug)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDevice {
    _handle: RawVkPhysicalDevice,
}

impl VkPhysicalDevice {
    
    pub fn handle(&self) -> RawVkPhysicalDevice {
        self._handle
    }
    
    pub fn get_list(instance: &VkInstance) -> Result<Vec<VkPhysicalDevice>, VkResult> {
        unsafe {
            let instance_handle = instance.handle();
            vk_call_retrieve_list(
                |count, ptr| vkEnumeratePhysicalDevices(instance_handle, count, ptr),
                |physical_device : &mut VkPhysicalDevice| {  }
            )
        }
    }
    
    pub fn get_supported_extensions(&self) -> Result<Vec<VkExtensionProperties>, VkResult> {
        unsafe {
            vk_call_retrieve_list(
                |count, ptr| vkEnumerateDeviceExtensionProperties(self._handle, null(), count, ptr),
                |extension_properties : &mut VkExtensionProperties| {  }
            )
        }
    }
    
    pub fn get_properties(&self) -> VkPhysicalDeviceProperties {
        unsafe {
            vk_call_retrieve_single_unchecked(
                |ptr| vkGetPhysicalDeviceProperties(self._handle, ptr),
                |physical_device_properties : &mut VkPhysicalDeviceProperties| {  }
            )
        }
    }
    
    pub fn get_features(&self) -> VkPhysicalDeviceFeatures {
        unsafe {
            vk_call_retrieve_single_unchecked(
                |ptr| vkGetPhysicalDeviceFeatures(self._handle, ptr),
                |physical_device_features : &mut VkPhysicalDeviceFeatures| {  }
            )
        }
    }
    
    pub fn get_queue_families(&self) -> Vec<VkQueueFamilyProperties> {
        unsafe {
            vk_call_retrieve_list_unchecked(
                |count, ptr| vkGetPhysicalDeviceQueueFamilyProperties(self._handle, count, ptr),
                |queue_family_properties : &mut VkQueueFamilyProperties| {  }
            )
        }
    }
    
    pub fn create_logical_device(&self, create_info: &VkDeviceCreateInfo) -> Result<VkDevice, VkResult> {
        VkDevice::new(self, create_info)
    }
}

impl VkFrom<VkPhysicalDevice> for RawVkPhysicalDevice {
    
    fn vk_from(value: &VkPhysicalDevice) -> Self {
        value._handle
    }
}

impl VkFrom<RawVkPhysicalDevice> for VkPhysicalDevice {
    
    fn vk_from(value: &RawVkPhysicalDevice) -> Self {
        Self {
            _handle: *value,
        }
    }
}

extern {
    fn vkEnumeratePhysicalDevices(instance: RawVkInstance, p_physical_device_count: *mut u32, p_physical_devices: *mut RawVkPhysicalDevice)-> RawVkResult;
    fn vkEnumerateDeviceExtensionProperties(physical_device: RawVkPhysicalDevice, p_layer_name: *const c_char, p_property_count: *mut u32, p_properties: *mut RawVkExtensionProperties)-> RawVkResult;
    fn vkGetPhysicalDeviceProperties(physical_device: RawVkPhysicalDevice, p_properties: *mut RawVkPhysicalDeviceProperties);
    fn vkGetPhysicalDeviceFeatures(physical_device: RawVkPhysicalDevice, p_features: *mut RawVkPhysicalDeviceFeatures);
    fn vkGetPhysicalDeviceQueueFamilyProperties(physical_device: RawVkPhysicalDevice, p_queue_family_property_count: *mut u32, p_queue_family_properties: *mut RawVkQueueFamilyProperties);
}