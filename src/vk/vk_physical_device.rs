// Generated by `scripts/generate_vk.js`

use vk::*;
use std::os::raw::c_char;
use std::vec::Vec;
use std::ptr::null;
use libc::c_void;
use glfw::*;

pub type RawVkPhysicalDevice = RawVkHandle;

#[derive(Debug)]
pub struct VkPhysicalDevice {
    _handle: RawVkPhysicalDevice,
}

impl VkPhysicalDevice {
    
    pub fn handle(&self) -> RawVkPhysicalDevice {
        self._handle
    }
    
    pub fn get_list(instance: &VkInstance) -> Result<Vec<VkPhysicalDevice>, VkResult> {
        unsafe {
            let instance_handle = instance.handle();
            vk_call_retrieve_list(
                |count, ptr| vkEnumeratePhysicalDevices(instance_handle, count, ptr),
                |physical_device : &mut VkPhysicalDevice| {  }
            )
        }
    }
    
    pub fn get_supported_extensions(&self) -> Result<Vec<VkExtensionProperties>, VkResult> {
        unsafe {
            vk_call_retrieve_list(
                |count, ptr| vkEnumerateDeviceExtensionProperties(self._handle, null(), count, ptr),
                |extension_properties : &mut VkExtensionProperties| {  }
            )
        }
    }
    
    pub fn get_properties(&self) -> VkPhysicalDeviceProperties {
        unsafe {
            vk_call_retrieve_single_unchecked(
                |ptr| vkGetPhysicalDeviceProperties(self._handle, ptr),
                |physical_device_properties : &mut VkPhysicalDeviceProperties| {  }
            )
        }
    }
    
    pub fn get_features(&self) -> VkPhysicalDeviceFeatures {
        unsafe {
            vk_call_retrieve_single_unchecked(
                |ptr| vkGetPhysicalDeviceFeatures(self._handle, ptr),
                |physical_device_features : &mut VkPhysicalDeviceFeatures| {  }
            )
        }
    }
    
    pub fn get_queue_families(&self) -> Vec<VkQueueFamilyProperties> {
        unsafe {
            vk_call_retrieve_list_unchecked(
                |count, ptr| vkGetPhysicalDeviceQueueFamilyProperties(self._handle, count, ptr),
                |queue_family_properties : &mut VkQueueFamilyProperties| {  }
            )
        }
    }
    
    pub fn create_logical_device(&self, create_info: &VkDeviceCreateInfo) -> Result<VkDevice, VkResult> {
        VkDevice::new(self, create_info)
    }
    
    pub fn does_support_surface(&self, queue_family_index: usize, surface: &VkSurface) -> Result<bool, VkResult> {
        unsafe {
            let surface_handle = surface.handle();
            vk_call_retrieve_single(
                |ptr| vkGetPhysicalDeviceSurfaceSupportKHR(self._handle, queue_family_index as u32, surface_handle, ptr),
                |bool32 : &mut bool| {  }
            )
        }
    }
    
    pub fn get_surface_capabilities(&self, surface: &VkSurface) -> Result<VkSurfaceCapabilities, VkResult> {
        unsafe {
            let surface_handle = surface.handle();
            vk_call_retrieve_single(
                |ptr| vkGetPhysicalDeviceSurfaceCapabilitiesKHR(self._handle, surface_handle, ptr),
                |surface_capabilities : &mut VkSurfaceCapabilities| {  }
            )
        }
    }
    
    pub fn get_surface_present_modes(&self, surface: &VkSurface) -> Result<Vec<VkPresentMode>, VkResult> {
        unsafe {
            let surface_handle = surface.handle();
            vk_call_retrieve_list(
                |count, ptr| vkGetPhysicalDeviceSurfacePresentModesKHR(self._handle, surface_handle, count, ptr),
                |present_mode : &mut VkPresentMode| {  }
            )
        }
    }
    
    pub fn get_surface_formats(&self, surface: &VkSurface) -> Result<Vec<VkSurfaceFormat>, VkResult> {
        unsafe {
            let surface_handle = surface.handle();
            vk_call_retrieve_list(
                |count, ptr| vkGetPhysicalDeviceSurfaceFormatsKHR(self._handle, surface_handle, count, ptr),
                |surface_format : &mut VkSurfaceFormat| {  }
            )
        }
    }
}

impl VkFrom<VkPhysicalDevice> for RawVkPhysicalDevice {
    
    fn vk_from(value: &VkPhysicalDevice) -> Self {
        value._handle
    }
}

impl VkFrom<RawVkPhysicalDevice> for VkPhysicalDevice {
    
    fn vk_from(value: &RawVkPhysicalDevice) -> Self {
        Self {
            _handle: *value,
        }
    }
}

extern {
    fn vkEnumeratePhysicalDevices(instance: RawVkInstance, p_physical_device_count: *mut u32, p_physical_devices: *mut RawVkPhysicalDevice)-> RawVkResult;
    fn vkEnumerateDeviceExtensionProperties(physical_device: RawVkPhysicalDevice, p_layer_name: *const c_char, p_property_count: *mut u32, p_properties: *mut RawVkExtensionProperties)-> RawVkResult;
    fn vkGetPhysicalDeviceProperties(physical_device: RawVkPhysicalDevice, p_properties: *mut RawVkPhysicalDeviceProperties);
    fn vkGetPhysicalDeviceFeatures(physical_device: RawVkPhysicalDevice, p_features: *mut RawVkPhysicalDeviceFeatures);
    fn vkGetPhysicalDeviceQueueFamilyProperties(physical_device: RawVkPhysicalDevice, p_queue_family_property_count: *mut u32, p_queue_family_properties: *mut RawVkQueueFamilyProperties);
    fn vkGetPhysicalDeviceSurfaceSupportKHR(physical_device: RawVkPhysicalDevice, queue_family_index: u32, surface: RawVkSurface, p_supported: *mut RawVkBool32)-> RawVkResult;
    fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device: RawVkPhysicalDevice, surface: RawVkSurface, p_surface_capabilities: *mut RawVkSurfaceCapabilities)-> RawVkResult;
    fn vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device: RawVkPhysicalDevice, surface: RawVkSurface, p_present_mode_count: *mut u32, p_present_modes: *mut RawVkPresentMode)-> RawVkResult;
    fn vkGetPhysicalDeviceSurfaceFormatsKHR(physical_device: RawVkPhysicalDevice, surface: RawVkSurface, p_surface_format_count: *mut u32, p_surface_formats: *mut RawVkSurfaceFormat)-> RawVkResult;
}