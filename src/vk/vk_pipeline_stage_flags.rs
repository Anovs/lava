// Generated by `scripts/generate_vk.js`

use utils::vk_type::*;

pub type RawVkPipelineStageFlags = u32;

#[derive(Debug, Copy, Clone)]
pub struct VkPipelineStageFlags {
    top_of_pipe: bool,
    draw_indirect: bool,
    vertex_input: bool,
    vertex_shader: bool,
    tessellation_control_shader: bool,
    tessellation_evaluation_shader: bool,
    geometry_shader: bool,
    fragment_shader: bool,
    early_fragment_tests: bool,
    late_fragment_tests: bool,
    color_attachment_output: bool,
    compute_shader: bool,
    transfer: bool,
    bottom_of_pipe: bool,
    host: bool,
    all_graphics: bool,
    all_commands: bool,
    command_process_nvx: bool,
}

impl VkRawType<VkPipelineStageFlags> for RawVkPipelineStageFlags {
    fn vk_to_wrapped(src: &RawVkPipelineStageFlags) -> VkPipelineStageFlags {
        VkPipelineStageFlags {
            top_of_pipe: (src & 0x00000001) != 0,
            draw_indirect: (src & 0x00000002) != 0,
            vertex_input: (src & 0x00000004) != 0,
            vertex_shader: (src & 0x00000008) != 0,
            tessellation_control_shader: (src & 0x00000010) != 0,
            tessellation_evaluation_shader: (src & 0x00000020) != 0,
            geometry_shader: (src & 0x00000040) != 0,
            fragment_shader: (src & 0x00000080) != 0,
            early_fragment_tests: (src & 0x00000100) != 0,
            late_fragment_tests: (src & 0x00000200) != 0,
            color_attachment_output: (src & 0x00000400) != 0,
            compute_shader: (src & 0x00000800) != 0,
            transfer: (src & 0x00001000) != 0,
            bottom_of_pipe: (src & 0x00002000) != 0,
            host: (src & 0x00004000) != 0,
            all_graphics: (src & 0x00008000) != 0,
            all_commands: (src & 0x00010000) != 0,
            command_process_nvx: (src & 0x00020000) != 0,
        }
    }
}

impl VkWrappedType<RawVkPipelineStageFlags> for VkPipelineStageFlags {
    fn vk_to_raw(src: &VkPipelineStageFlags, dst: &mut RawVkPipelineStageFlags) {
        *dst = 0;
        if src.top_of_pipe { *dst |= 0x00000001; }
        if src.draw_indirect { *dst |= 0x00000002; }
        if src.vertex_input { *dst |= 0x00000004; }
        if src.vertex_shader { *dst |= 0x00000008; }
        if src.tessellation_control_shader { *dst |= 0x00000010; }
        if src.tessellation_evaluation_shader { *dst |= 0x00000020; }
        if src.geometry_shader { *dst |= 0x00000040; }
        if src.fragment_shader { *dst |= 0x00000080; }
        if src.early_fragment_tests { *dst |= 0x00000100; }
        if src.late_fragment_tests { *dst |= 0x00000200; }
        if src.color_attachment_output { *dst |= 0x00000400; }
        if src.compute_shader { *dst |= 0x00000800; }
        if src.transfer { *dst |= 0x00001000; }
        if src.bottom_of_pipe { *dst |= 0x00002000; }
        if src.host { *dst |= 0x00004000; }
        if src.all_graphics { *dst |= 0x00008000; }
        if src.all_commands { *dst |= 0x00010000; }
        if src.command_process_nvx { *dst |= 0x00020000; }
    }
}

impl VkDefault for VkPipelineStageFlags {
    fn vk_default() -> VkPipelineStageFlags {
        VkPipelineStageFlags {
            top_of_pipe: false,
            draw_indirect: false,
            vertex_input: false,
            vertex_shader: false,
            tessellation_control_shader: false,
            tessellation_evaluation_shader: false,
            geometry_shader: false,
            fragment_shader: false,
            early_fragment_tests: false,
            late_fragment_tests: false,
            color_attachment_output: false,
            compute_shader: false,
            transfer: false,
            bottom_of_pipe: false,
            host: false,
            all_graphics: false,
            all_commands: false,
            command_process_nvx: false,
        }
    }
}