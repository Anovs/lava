// Generated by `scripts/generate_vk.js`

use utils::vk_type::*;

pub type RawVkSubgroupFeatureFlags = u32;

#[derive(Debug, Copy, Clone)]
pub struct VkSubgroupFeatureFlags {
    basic: bool,
    vote: bool,
    arithmetic: bool,
    ballot: bool,
    shuffle: bool,
    shuffle_relative: bool,
    clustered: bool,
    quad: bool,
    partitioned_nv: bool,
}

impl VkRawType<VkSubgroupFeatureFlags> for RawVkSubgroupFeatureFlags {
    
    fn vk_to_wrapped(src: &RawVkSubgroupFeatureFlags) -> VkSubgroupFeatureFlags {
        VkSubgroupFeatureFlags {
            basic: (src & 0x00000001) != 0,
            vote: (src & 0x00000002) != 0,
            arithmetic: (src & 0x00000004) != 0,
            ballot: (src & 0x00000008) != 0,
            shuffle: (src & 0x00000010) != 0,
            shuffle_relative: (src & 0x00000020) != 0,
            clustered: (src & 0x00000040) != 0,
            quad: (src & 0x00000080) != 0,
            partitioned_nv: (src & 0x00000100) != 0,
        }
    }
}

impl VkWrappedType<RawVkSubgroupFeatureFlags> for VkSubgroupFeatureFlags {
    
    fn vk_to_raw(src: &VkSubgroupFeatureFlags, dst: &mut RawVkSubgroupFeatureFlags) {
        *dst = 0;
        if src.basic { *dst |= 0x00000001; }
        if src.vote { *dst |= 0x00000002; }
        if src.arithmetic { *dst |= 0x00000004; }
        if src.ballot { *dst |= 0x00000008; }
        if src.shuffle { *dst |= 0x00000010; }
        if src.shuffle_relative { *dst |= 0x00000020; }
        if src.clustered { *dst |= 0x00000040; }
        if src.quad { *dst |= 0x00000080; }
        if src.partitioned_nv { *dst |= 0x00000100; }
    }
    
    fn vk_default() -> VkSubgroupFeatureFlags {
        VkSubgroupFeatureFlags {
            basic: false,
            vote: false,
            arithmetic: false,
            ballot: false,
            shuffle: false,
            shuffle_relative: false,
            clustered: false,
            quad: false,
            partitioned_nv: false,
        }
    }
}